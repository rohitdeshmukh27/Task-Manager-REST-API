# ğŸ§ª Code Quality & Testing - Complete Implementation Guide

## ğŸ“‹ Level 2: Professional Development Practices

Add **testing, documentation, and code quality tools** to your Task Manager API:

- **Jest + Supertest** - Unit & Integration Testing
- **Swagger/OpenAPI** - Interactive API Documentation
- **ESLint + Prettier** - Code Linting & Formatting
- **AsyncHandler** - Clean Controller Code

**Time to Complete:** 3-4 hours

---

# ğŸ¯ Why Code Quality Matters?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CODE QUALITY BENEFITS                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  ğŸ§ª TESTING:                                                    â”‚
â”‚  â€¢ Catch bugs before production                                 â”‚
â”‚  â€¢ Refactor with confidence                                     â”‚
â”‚  â€¢ Document expected behavior                                   â”‚
â”‚  â€¢ Required for CI/CD pipelines                                 â”‚
â”‚                                                                  â”‚
â”‚  ğŸ“š DOCUMENTATION:                                              â”‚
â”‚  â€¢ Developers can explore API interactively                     â”‚
â”‚  â€¢ Auto-generated from code comments                            â”‚
â”‚  â€¢ Always up-to-date with implementation                        â”‚
â”‚  â€¢ Industry standard (OpenAPI 3.0)                              â”‚
â”‚                                                                  â”‚
â”‚  âœ¨ LINTING & FORMATTING:                                       â”‚
â”‚  â€¢ Consistent code style across team                            â”‚
â”‚  â€¢ Catch errors before runtime                                  â”‚
â”‚  â€¢ Auto-fix common issues                                       â”‚
â”‚  â€¢ Enforced code standards                                      â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ğŸ—ï¸ Updated Architecture

```
task-manager-api/
â”‚
â”œâ”€â”€ ğŸ“ src/
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ config/
â”‚   â”‚   â”œâ”€â”€ supabase.ts
â”‚   â”‚   â”œâ”€â”€ rateLimiter.ts
â”‚   â”‚   â””â”€â”€ swagger.ts              # [NEW] Swagger configuration
â”‚   â”‚
â”‚   â””â”€â”€ ... (existing files)
â”‚
â”œâ”€â”€ ğŸ“ tests/                        # [NEW] Test directory
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ unit/                     # Unit tests
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ taskService.test.ts
â”‚   â”‚   â””â”€â”€ middleware/
â”‚   â”‚       â””â”€â”€ validateTask.test.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ integration/              # Integration tests
â”‚   â”‚   â”œâ”€â”€ tasks.test.ts
â”‚   â”‚   â””â”€â”€ auth.test.ts
â”‚   â”‚
â”‚   â””â”€â”€ setup.ts                     # Test configuration
â”‚
â”œâ”€â”€ .eslintrc.json                   # [NEW] ESLint configuration
â”œâ”€â”€ .prettierrc                      # [NEW] Prettier configuration
â”œâ”€â”€ jest.config.js                   # [NEW] Jest configuration
â””â”€â”€ package.json                     # Updated with new scripts
```

---

# ğŸ› ï¸ STEP-BY-STEP IMPLEMENTATION

---

## PHASE 1: SETUP TESTING WITH JEST

---

### STEP 1: Install Testing Dependencies

```bash
# Install Jest and related packages
npm install -D jest ts-jest @types/jest supertest @types/supertest

# Initialize Jest configuration
npx ts-jest config:init
```

### Package Explanation:

| Package            | Purpose                          |
| ------------------ | -------------------------------- |
| `jest`             | JavaScript testing framework     |
| `ts-jest`          | TypeScript preprocessor for Jest |
| `@types/jest`      | TypeScript types for Jest        |
| `supertest`        | HTTP testing library             |
| `@types/supertest` | TypeScript types for Supertest   |

---

### STEP 2: Create Jest Configuration

ğŸ“ **File:** `jest.config.js`

```javascript
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  // Use ts-jest preset for TypeScript
  preset: "ts-jest",

  // Test environment
  testEnvironment: "node",

  // Root directory for tests
  roots: ["<rootDir>/tests"],

  // File patterns to match for tests
  testMatch: ["**/*.test.ts", "**/*.spec.ts"],

  // Module file extensions
  moduleFileExtensions: ["ts", "js", "json"],

  // Coverage configuration
  collectCoverage: true,
  coverageDirectory: "coverage",
  coverageReporters: ["text", "lcov", "html"],
  collectCoverageFrom: [
    "src/**/*.ts",
    "!src/**/*.d.ts",
    "!src/app.ts", // Exclude entry point
  ],

  // Coverage thresholds (enforce minimum coverage)
  coverageThreshold: {
    global: {
      branches: 60,
      functions: 60,
      lines: 60,
      statements: 60,
    },
  },

  // Setup file to run before tests
  setupFilesAfterEnv: ["<rootDir>/tests/setup.ts"],

  // Clear mocks between tests
  clearMocks: true,

  // Verbose output
  verbose: true,

  // Timeout for each test (in ms)
  testTimeout: 10000,

  // Transform TypeScript files
  transform: {
    "^.+\\.ts$": [
      "ts-jest",
      {
        tsconfig: "tsconfig.json",
      },
    ],
  },

  // Module path aliases (if using)
  moduleNameMapper: {
    "^@/(.*)$": "<rootDir>/src/$1",
  },
};
```

---

### STEP 3: Create Test Setup File

ğŸ“ **File:** `tests/setup.ts`

```typescript
// ============================================
// JEST TEST SETUP
// ============================================

import dotenv from "dotenv";

// Load test environment variables
dotenv.config({ path: ".env.test" });

// Set test environment
process.env.NODE_ENV = "test";

// Global test timeout
jest.setTimeout(10000);

// Suppress console logs during tests (optional)
// Uncomment to hide console output during tests
// global.console = {
//   ...console,
//   log: jest.fn(),
//   debug: jest.fn(),
//   info: jest.fn(),
//   warn: jest.fn(),
//   error: jest.fn(),
// };

// Clean up after all tests
afterAll(async () => {
  // Add cleanup logic here if needed
  // e.g., close database connections
});

// Reset mocks before each test
beforeEach(() => {
  jest.clearAllMocks();
});
```

---

### STEP 4: Create Test Environment File

ğŸ“ **File:** `.env.test`

```env
# Test Environment Configuration
NODE_ENV=test
PORT=3001

# Use test/mock Supabase credentials
SUPABASE_URL=https://test-project.supabase.co
SUPABASE_ANON_KEY=test-anon-key

# Test JWT
JWT_SECRET=test-jwt-secret-for-testing-only

# Test URLs
FRONTEND_URL=http://localhost:3001
PASSWORD_RESET_URL=http://localhost:3001/reset-password
```

---

### STEP 5: Create Unit Tests for Task Service

ğŸ“ **File:** `tests/unit/services/taskService.test.ts`

```typescript
// ============================================
// TASK SERVICE UNIT TESTS
// ============================================

import * as TaskService from "../../../src/services/taskService";
import supabase from "../../../src/config/supabase";

// Mock the Supabase client
jest.mock("../../../src/config/supabase", () => ({
  from: jest.fn(),
}));

describe("TaskService", () => {
  // Reset mocks before each test
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // ==========================================
  // getAllTasks Tests
  // ==========================================
  describe("getAllTasks", () => {
    it("should return all tasks successfully", async () => {
      // Arrange: Setup mock data
      const mockTasks = [
        {
          id: "123e4567-e89b-12d3-a456-426614174000",
          title: "Test Task 1",
          description: "Description 1",
          status: "pending",
          priority: "medium",
          due_date: null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        },
        {
          id: "223e4567-e89b-12d3-a456-426614174001",
          title: "Test Task 2",
          description: "Description 2",
          status: "completed",
          priority: "high",
          due_date: "2024-12-31",
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        },
      ];

      // Setup mock chain
      const mockQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        or: jest.fn().mockReturnThis(),
        order: jest.fn().mockReturnThis(),
        limit: jest.fn().mockReturnThis(),
        range: jest.fn().mockReturnThis(),
      };

      // Final return value
      mockQuery.order.mockResolvedValue({
        data: mockTasks,
        error: null,
        count: 2,
      });

      (supabase.from as jest.Mock).mockReturnValue(mockQuery);

      // Act: Call the function
      const result = await TaskService.getAllTasks({});

      // Assert: Check results
      expect(supabase.from).toHaveBeenCalledWith("tasks");
      expect(result.data).toHaveLength(2);
      expect(result.error).toBeNull();
      expect(result.count).toBe(2);
    });

    it("should filter tasks by status", async () => {
      // Arrange
      const mockQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        or: jest.fn().mockReturnThis(),
        order: jest.fn().mockReturnThis(),
        limit: jest.fn().mockReturnThis(),
        range: jest.fn().mockReturnThis(),
      };

      mockQuery.order.mockResolvedValue({
        data: [],
        error: null,
        count: 0,
      });

      (supabase.from as jest.Mock).mockReturnValue(mockQuery);

      // Act
      await TaskService.getAllTasks({ status: "pending" });

      // Assert
      expect(mockQuery.eq).toHaveBeenCalledWith("status", "pending");
    });

    it("should handle database errors", async () => {
      // Arrange
      const mockError = {
        message: "Database connection failed",
        code: "CONNECTION_ERROR",
      };

      const mockQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        or: jest.fn().mockReturnThis(),
        order: jest.fn().mockReturnThis(),
        limit: jest.fn().mockReturnThis(),
        range: jest.fn().mockReturnThis(),
      };

      mockQuery.order.mockResolvedValue({
        data: null,
        error: mockError,
        count: null,
      });

      (supabase.from as jest.Mock).mockReturnValue(mockQuery);

      // Act
      const result = await TaskService.getAllTasks({});

      // Assert
      expect(result.data).toBeNull();
      expect(result.error).toEqual(mockError);
    });
  });

  // ==========================================
  // getTaskById Tests
  // ==========================================
  describe("getTaskById", () => {
    it("should return a single task by ID", async () => {
      // Arrange
      const mockTask = {
        id: "123e4567-e89b-12d3-a456-426614174000",
        title: "Test Task",
        description: "Test Description",
        status: "pending",
        priority: "medium",
        due_date: null,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      const mockQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: mockTask,
          error: null,
        }),
      };

      (supabase.from as jest.Mock).mockReturnValue(mockQuery);

      // Act
      const result = await TaskService.getTaskById(mockTask.id);

      // Assert
      expect(supabase.from).toHaveBeenCalledWith("tasks");
      expect(mockQuery.eq).toHaveBeenCalledWith("id", mockTask.id);
      expect(result.data).toEqual(mockTask);
      expect(result.error).toBeNull();
    });

    it("should return error for non-existent task", async () => {
      // Arrange
      const mockQuery = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: null,
          error: { message: "No rows found", code: "PGRST116" },
        }),
      };

      (supabase.from as jest.Mock).mockReturnValue(mockQuery);

      // Act
      const result = await TaskService.getTaskById("non-existent-id");

      // Assert
      expect(result.data).toBeNull();
      expect(result.error).toBeTruthy();
    });
  });

  // ==========================================
  // createTask Tests
  // ==========================================
  describe("createTask", () => {
    it("should create a new task successfully", async () => {
      // Arrange
      const newTaskData = {
        title: "New Task",
        description: "New Description",
        priority: "high" as const,
      };

      const createdTask = {
        id: "new-task-id",
        ...newTaskData,
        status: "pending",
        due_date: null,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      const mockQuery = {
        insert: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: createdTask,
          error: null,
        }),
      };

      (supabase.from as jest.Mock).mockReturnValue(mockQuery);

      // Act
      const result = await TaskService.createTask(newTaskData);

      // Assert
      expect(mockQuery.insert).toHaveBeenCalledWith(
        expect.objectContaining({
          title: newTaskData.title,
          description: newTaskData.description,
          priority: newTaskData.priority,
          status: "pending",
        }),
      );
      expect(result.data).toEqual(createdTask);
      expect(result.error).toBeNull();
    });
  });

  // ==========================================
  // updateTask Tests
  // ==========================================
  describe("updateTask", () => {
    it("should update an existing task", async () => {
      // Arrange
      const taskId = "123e4567-e89b-12d3-a456-426614174000";
      const updates = {
        title: "Updated Title",
        status: "completed" as const,
      };

      const updatedTask = {
        id: taskId,
        title: updates.title,
        description: "Original description",
        status: updates.status,
        priority: "medium",
        due_date: null,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      const mockQuery = {
        update: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: updatedTask,
          error: null,
        }),
      };

      (supabase.from as jest.Mock).mockReturnValue(mockQuery);

      // Act
      const result = await TaskService.updateTask(taskId, updates);

      // Assert
      expect(mockQuery.update).toHaveBeenCalledWith(
        expect.objectContaining({
          title: updates.title,
          status: updates.status,
        }),
      );
      expect(mockQuery.eq).toHaveBeenCalledWith("id", taskId);
      expect(result.data?.status).toBe("completed");
    });
  });

  // ==========================================
  // deleteTask Tests
  // ==========================================
  describe("deleteTask", () => {
    it("should delete an existing task", async () => {
      // Arrange
      const taskId = "123e4567-e89b-12d3-a456-426614174000";
      const existingTask = {
        id: taskId,
        title: "Task to delete",
        description: null,
        status: "pending",
        priority: "low",
        due_date: null,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      // Mock getTaskById first (to get existing task)
      const selectMock = {
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: existingTask,
          error: null,
        }),
      };

      // Mock delete
      const deleteMock = {
        delete: jest.fn().mockReturnThis(),
        eq: jest.fn().mockResolvedValue({
          error: null,
        }),
      };

      // Setup from() to return different mocks based on call
      let callCount = 0;
      (supabase.from as jest.Mock).mockImplementation(() => {
        callCount++;
        return callCount === 1 ? selectMock : deleteMock;
      });

      // Act
      const result = await TaskService.deleteTask(taskId);

      // Assert
      expect(result.data).toEqual(existingTask);
      expect(result.error).toBeNull();
    });
  });
});
```

### ğŸ’¡ Test Structure (AAA Pattern):

```
1. ARRANGE  - Set up test data and mocks
2. ACT      - Call the function being tested
3. ASSERT   - Verify the results
```

---

### STEP 6: Create Integration Tests

ğŸ“ **File:** `tests/integration/tasks.test.ts`

```typescript
// ============================================
// TASK API INTEGRATION TESTS
// ============================================

import request from "supertest";
import express from "express";
import taskRoutes from "../../src/routes/taskRoutes";

// Create test app
const app = express();
app.use(express.json());
app.use("/api/tasks", taskRoutes);

// Mock the auth middleware for testing
jest.mock("../../src/middleware/authMiddleware", () => ({
  authenticate: (req: any, res: any, next: any) => {
    req.user = { id: "test-user-id", email: "test@example.com" };
    next();
  },
  requireVerifiedEmail: (req: any, res: any, next: any) => next(),
}));

// Mock the task service
jest.mock("../../src/services/taskService");
import * as TaskService from "../../src/services/taskService";

describe("Task API Integration Tests", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // ==========================================
  // GET /api/tasks Tests
  // ==========================================
  describe("GET /api/tasks", () => {
    it("should return all tasks with 200 status", async () => {
      // Arrange
      const mockTasks = [
        { id: "1", title: "Task 1", status: "pending", priority: "low" },
        { id: "2", title: "Task 2", status: "completed", priority: "high" },
      ];

      (TaskService.getAllTasks as jest.Mock).mockResolvedValue({
        data: mockTasks,
        error: null,
        count: 2,
      });

      // Act
      const response = await request(app)
        .get("/api/tasks")
        .expect("Content-Type", /json/)
        .expect(200);

      // Assert
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveLength(2);
      expect(response.body.count).toBe(2);
    });

    it("should filter tasks by status query param", async () => {
      // Arrange
      (TaskService.getAllTasks as jest.Mock).mockResolvedValue({
        data: [],
        error: null,
        count: 0,
      });

      // Act
      await request(app).get("/api/tasks?status=pending").expect(200);

      // Assert
      expect(TaskService.getAllTasks).toHaveBeenCalledWith(
        expect.objectContaining({ status: "pending" }),
      );
    });

    it("should return 400 for invalid status", async () => {
      // Act
      const response = await request(app)
        .get("/api/tasks?status=invalid")
        .expect(400);

      // Assert
      expect(response.body.success).toBe(false);
    });

    it("should handle service errors", async () => {
      // Arrange
      (TaskService.getAllTasks as jest.Mock).mockResolvedValue({
        data: null,
        error: { message: "Database error" },
        count: null,
      });

      // Act
      const response = await request(app).get("/api/tasks").expect(500);

      // Assert
      expect(response.body.success).toBe(false);
    });
  });

  // ==========================================
  // GET /api/tasks/:id Tests
  // ==========================================
  describe("GET /api/tasks/:id", () => {
    it("should return a task by valid UUID", async () => {
      // Arrange
      const mockTask = {
        id: "123e4567-e89b-12d3-a456-426614174000",
        title: "Test Task",
        status: "pending",
        priority: "medium",
      };

      (TaskService.getTaskById as jest.Mock).mockResolvedValue({
        data: mockTask,
        error: null,
      });

      // Act
      const response = await request(app)
        .get(`/api/tasks/${mockTask.id}`)
        .expect(200);

      // Assert
      expect(response.body.success).toBe(true);
      expect(response.body.data.id).toBe(mockTask.id);
    });

    it("should return 400 for invalid UUID format", async () => {
      // Act
      const response = await request(app)
        .get("/api/tasks/invalid-uuid")
        .expect(400);

      // Assert
      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain("Invalid");
    });

    it("should return 404 for non-existent task", async () => {
      // Arrange
      (TaskService.getTaskById as jest.Mock).mockResolvedValue({
        data: null,
        error: null,
      });

      // Act
      const response = await request(app)
        .get("/api/tasks/123e4567-e89b-12d3-a456-426614174000")
        .expect(404);

      // Assert
      expect(response.body.success).toBe(false);
    });
  });

  // ==========================================
  // POST /api/tasks Tests
  // ==========================================
  describe("POST /api/tasks", () => {
    it("should create a new task with valid data", async () => {
      // Arrange
      const newTask = {
        title: "New Task",
        description: "Task description",
        priority: "high",
      };

      const createdTask = {
        id: "new-task-id",
        ...newTask,
        status: "pending",
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      (TaskService.createTask as jest.Mock).mockResolvedValue({
        data: createdTask,
        error: null,
      });

      // Act
      const response = await request(app)
        .post("/api/tasks")
        .send(newTask)
        .expect("Content-Type", /json/)
        .expect(201);

      // Assert
      expect(response.body.success).toBe(true);
      expect(response.body.data.title).toBe(newTask.title);
    });

    it("should return 400 when title is missing", async () => {
      // Act
      const response = await request(app)
        .post("/api/tasks")
        .send({ description: "No title" })
        .expect(400);

      // Assert
      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain("title");
    });

    it("should return 400 for invalid priority", async () => {
      // Act
      const response = await request(app)
        .post("/api/tasks")
        .send({ title: "Task", priority: "invalid" })
        .expect(400);

      // Assert
      expect(response.body.success).toBe(false);
    });
  });

  // ==========================================
  // PUT /api/tasks/:id Tests
  // ==========================================
  describe("PUT /api/tasks/:id", () => {
    const validUUID = "123e4567-e89b-12d3-a456-426614174000";

    it("should update a task successfully", async () => {
      // Arrange
      const updates = { title: "Updated Title", status: "completed" };
      const updatedTask = {
        id: validUUID,
        ...updates,
        priority: "medium",
      };

      (TaskService.updateTask as jest.Mock).mockResolvedValue({
        data: updatedTask,
        error: null,
      });

      // Act
      const response = await request(app)
        .put(`/api/tasks/${validUUID}`)
        .send(updates)
        .expect(200);

      // Assert
      expect(response.body.success).toBe(true);
      expect(response.body.data.title).toBe(updates.title);
    });

    it("should return 400 for invalid status value", async () => {
      // Act
      const response = await request(app)
        .put(`/api/tasks/${validUUID}`)
        .send({ status: "invalid-status" })
        .expect(400);

      // Assert
      expect(response.body.success).toBe(false);
    });

    it("should return 400 for empty update body", async () => {
      // Act
      const response = await request(app)
        .put(`/api/tasks/${validUUID}`)
        .send({})
        .expect(400);

      // Assert
      expect(response.body.success).toBe(false);
    });
  });

  // ==========================================
  // DELETE /api/tasks/:id Tests
  // ==========================================
  describe("DELETE /api/tasks/:id", () => {
    const validUUID = "123e4567-e89b-12d3-a456-426614174000";

    it("should delete a task successfully", async () => {
      // Arrange
      const deletedTask = {
        id: validUUID,
        title: "Deleted Task",
      };

      (TaskService.deleteTask as jest.Mock).mockResolvedValue({
        data: deletedTask,
        error: null,
      });

      // Act
      const response = await request(app)
        .delete(`/api/tasks/${validUUID}`)
        .expect(200);

      // Assert
      expect(response.body.success).toBe(true);
      expect(response.body.message).toContain("deleted");
    });

    it("should return 404 for non-existent task", async () => {
      // Arrange
      (TaskService.deleteTask as jest.Mock).mockResolvedValue({
        data: null,
        error: null,
      });

      // Act
      const response = await request(app)
        .delete(`/api/tasks/${validUUID}`)
        .expect(404);

      // Assert
      expect(response.body.success).toBe(false);
    });
  });
});
```

---

### STEP 7: Create Validation Middleware Tests

ğŸ“ **File:** `tests/unit/middleware/validateTask.test.ts`

```typescript
// ============================================
// VALIDATION MIDDLEWARE UNIT TESTS
// ============================================

import { Request, Response, NextFunction } from "express";
import {
  validateCreateTask,
  validateUpdateTask,
  validateTaskId,
  validateQueryParams,
} from "../../../src/middleware/validateTask";

// Mock Express request/response
const mockRequest = (data: Partial<Request> = {}): Partial<Request> => ({
  body: {},
  params: {},
  query: {},
  ...data,
});

const mockResponse = (): Partial<Response> => {
  const res: Partial<Response> = {};
  res.status = jest.fn().mockReturnValue(res);
  res.json = jest.fn().mockReturnValue(res);
  return res;
};

const mockNext: NextFunction = jest.fn();

describe("Task Validation Middleware", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // ==========================================
  // validateCreateTask Tests
  // ==========================================
  describe("validateCreateTask", () => {
    it("should pass with valid task data", () => {
      // Arrange
      const req = mockRequest({
        body: {
          title: "Valid Task",
          description: "Description",
          priority: "medium",
        },
      });
      const res = mockResponse();

      // Act
      validateCreateTask(req as Request, res as Response, mockNext);

      // Assert
      expect(mockNext).toHaveBeenCalled();
      expect(res.status).not.toHaveBeenCalled();
    });

    it("should fail when title is missing", () => {
      // Arrange
      const req = mockRequest({
        body: { description: "No title" },
      });
      const res = mockResponse();

      // Act
      validateCreateTask(req as Request, res as Response, mockNext);

      // Assert
      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.json).toHaveBeenCalledWith(
        expect.objectContaining({ success: false }),
      );
      expect(mockNext).not.toHaveBeenCalled();
    });

    it("should fail when title is empty string", () => {
      // Arrange
      const req = mockRequest({
        body: { title: "" },
      });
      const res = mockResponse();

      // Act
      validateCreateTask(req as Request, res as Response, mockNext);

      // Assert
      expect(res.status).toHaveBeenCalledWith(400);
    });

    it("should fail when title is too long", () => {
      // Arrange
      const req = mockRequest({
        body: { title: "a".repeat(256) }, // 256 characters
      });
      const res = mockResponse();

      // Act
      validateCreateTask(req as Request, res as Response, mockNext);

      // Assert
      expect(res.status).toHaveBeenCalledWith(400);
    });

    it("should fail with invalid priority", () => {
      // Arrange
      const req = mockRequest({
        body: { title: "Task", priority: "invalid" },
      });
      const res = mockResponse();

      // Act
      validateCreateTask(req as Request, res as Response, mockNext);

      // Assert
      expect(res.status).toHaveBeenCalledWith(400);
    });

    it("should accept all valid priority values", () => {
      const priorities = ["low", "medium", "high"];

      priorities.forEach((priority) => {
        // Arrange
        const req = mockRequest({
          body: { title: "Task", priority },
        });
        const res = mockResponse();
        const next = jest.fn();

        // Act
        validateCreateTask(req as Request, res as Response, next);

        // Assert
        expect(next).toHaveBeenCalled();
      });
    });
  });

  // ==========================================
  // validateTaskId Tests
  // ==========================================
  describe("validateTaskId", () => {
    it("should pass with valid UUID", () => {
      // Arrange
      const req = mockRequest({
        params: { id: "123e4567-e89b-12d3-a456-426614174000" },
      });
      const res = mockResponse();

      // Act
      validateTaskId(req as Request, res as Response, mockNext);

      // Assert
      expect(mockNext).toHaveBeenCalled();
    });

    it("should fail with invalid UUID", () => {
      // Arrange
      const req = mockRequest({
        params: { id: "invalid-uuid" },
      });
      const res = mockResponse();

      // Act
      validateTaskId(req as Request, res as Response, mockNext);

      // Assert
      expect(res.status).toHaveBeenCalledWith(400);
    });

    it("should fail with empty ID", () => {
      // Arrange
      const req = mockRequest({
        params: { id: "" },
      });
      const res = mockResponse();

      // Act
      validateTaskId(req as Request, res as Response, mockNext);

      // Assert
      expect(res.status).toHaveBeenCalledWith(400);
    });
  });

  // ==========================================
  // validateQueryParams Tests
  // ==========================================
  describe("validateQueryParams", () => {
    it("should pass with no query params", () => {
      // Arrange
      const req = mockRequest({ query: {} });
      const res = mockResponse();

      // Act
      validateQueryParams(req as Request, res as Response, mockNext);

      // Assert
      expect(mockNext).toHaveBeenCalled();
    });

    it("should pass with valid query params", () => {
      // Arrange
      const req = mockRequest({
        query: {
          status: "pending",
          priority: "high",
          limit: "10",
          offset: "0",
        },
      });
      const res = mockResponse();

      // Act
      validateQueryParams(req as Request, res as Response, mockNext);

      // Assert
      expect(mockNext).toHaveBeenCalled();
    });

    it("should fail with invalid status", () => {
      // Arrange
      const req = mockRequest({
        query: { status: "invalid" },
      });
      const res = mockResponse();

      // Act
      validateQueryParams(req as Request, res as Response, mockNext);

      // Assert
      expect(res.status).toHaveBeenCalledWith(400);
    });

    it("should fail with negative limit", () => {
      // Arrange
      const req = mockRequest({
        query: { limit: "-5" },
      });
      const res = mockResponse();

      // Act
      validateQueryParams(req as Request, res as Response, mockNext);

      // Assert
      expect(res.status).toHaveBeenCalledWith(400);
    });
  });
});
```

---

### STEP 8: Update package.json with Test Scripts

ğŸ“ **File:** `package.json` (add to scripts)

```json
{
  "scripts": {
    "start": "node dist/app.js",
    "dev": "nodemon src/app.ts",
    "build": "tsc",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:unit": "jest tests/unit",
    "test:integration": "jest tests/integration",
    "test:ci": "jest --ci --coverage --reporters=default --reporters=jest-junit"
  }
}
```

---

## PHASE 2: SWAGGER API DOCUMENTATION

---

### STEP 9: Install Swagger Dependencies

```bash
npm install swagger-ui-express swagger-jsdoc
npm install -D @types/swagger-ui-express @types/swagger-jsdoc
```

---

### STEP 10: Create Swagger Configuration

ğŸ“ **File:** `src/config/swagger.ts`

```typescript
// ============================================
// SWAGGER CONFIGURATION - API Documentation
// ============================================

import swaggerJsdoc from "swagger-jsdoc";
import swaggerUi from "swagger-ui-express";
import { Application } from "express";

/**
 * Swagger/OpenAPI configuration
 */
const swaggerOptions: swaggerJsdoc.Options = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "Task Manager REST API",
      version: "1.0.0",
      description: `
A complete Task Manager REST API built with Node.js, Express, TypeScript, and Supabase.

## Features
- ğŸ“‹ Full CRUD operations for tasks
- ğŸ” JWT-based authentication
- ğŸ›¡ï¸ Rate limiting and security headers
- ğŸ“Š Task statistics and filtering

## Authentication
Most endpoints require authentication via JWT token.
Include the token in the Authorization header:
\`\`\`
Authorization: Bearer <your-access-token>
\`\`\`
      `,
      contact: {
        name: "API Support",
        email: "support@taskmanager.com",
      },
      license: {
        name: "MIT",
        url: "https://opensource.org/licenses/MIT",
      },
    },
    servers: [
      {
        url: "http://localhost:3000",
        description: "Development server",
      },
      {
        url: "https://api.taskmanager.com",
        description: "Production server",
      },
    ],
    tags: [
      {
        name: "Tasks",
        description: "Task management endpoints",
      },
      {
        name: "Authentication",
        description: "User authentication endpoints",
      },
      {
        name: "Health",
        description: "API health check endpoints",
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: "http",
          scheme: "bearer",
          bearerFormat: "JWT",
          description: "Enter your JWT token",
        },
      },
      schemas: {
        // Task Schema
        Task: {
          type: "object",
          properties: {
            id: {
              type: "string",
              format: "uuid",
              description: "Unique task identifier",
              example: "123e4567-e89b-12d3-a456-426614174000",
            },
            title: {
              type: "string",
              description: "Task title",
              example: "Complete project documentation",
            },
            description: {
              type: "string",
              nullable: true,
              description: "Detailed task description",
              example: "Write comprehensive API documentation with examples",
            },
            status: {
              type: "string",
              enum: ["pending", "in-progress", "completed"],
              description: "Current task status",
              example: "pending",
            },
            priority: {
              type: "string",
              enum: ["low", "medium", "high"],
              description: "Task priority level",
              example: "medium",
            },
            due_date: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "Task due date",
              example: "2024-12-31T23:59:59Z",
            },
            created_at: {
              type: "string",
              format: "date-time",
              description: "Creation timestamp",
            },
            updated_at: {
              type: "string",
              format: "date-time",
              description: "Last update timestamp",
            },
          },
        },
        // Create Task DTO
        CreateTaskDTO: {
          type: "object",
          required: ["title"],
          properties: {
            title: {
              type: "string",
              minLength: 1,
              maxLength: 255,
              description: "Task title (required)",
              example: "New Task",
            },
            description: {
              type: "string",
              description: "Task description (optional)",
              example: "Task details here",
            },
            priority: {
              type: "string",
              enum: ["low", "medium", "high"],
              default: "medium",
              description: "Task priority (optional)",
            },
            due_date: {
              type: "string",
              format: "date",
              description: "Due date in ISO format (optional)",
              example: "2024-12-31",
            },
          },
        },
        // Update Task DTO
        UpdateTaskDTO: {
          type: "object",
          minProperties: 1,
          properties: {
            title: {
              type: "string",
              minLength: 1,
              maxLength: 255,
            },
            description: {
              type: "string",
            },
            status: {
              type: "string",
              enum: ["pending", "in-progress", "completed"],
            },
            priority: {
              type: "string",
              enum: ["low", "medium", "high"],
            },
            due_date: {
              type: "string",
              format: "date",
            },
          },
        },
        // User Schema
        User: {
          type: "object",
          properties: {
            id: {
              type: "string",
              format: "uuid",
            },
            email: {
              type: "string",
              format: "email",
            },
            email_confirmed_at: {
              type: "string",
              format: "date-time",
              nullable: true,
            },
            created_at: {
              type: "string",
              format: "date-time",
            },
          },
        },
        // Login DTO
        LoginDTO: {
          type: "object",
          required: ["email", "password"],
          properties: {
            email: {
              type: "string",
              format: "email",
              example: "user@example.com",
            },
            password: {
              type: "string",
              minLength: 6,
              example: "SecurePassword123",
            },
          },
        },
        // Signup DTO
        SignupDTO: {
          type: "object",
          required: ["email", "password"],
          properties: {
            email: {
              type: "string",
              format: "email",
              example: "newuser@example.com",
            },
            password: {
              type: "string",
              minLength: 6,
              example: "SecurePassword123",
            },
            name: {
              type: "string",
              example: "John Doe",
            },
          },
        },
        // API Response
        ApiResponse: {
          type: "object",
          properties: {
            success: {
              type: "boolean",
            },
            message: {
              type: "string",
            },
            data: {
              type: "object",
            },
            error: {
              type: "string",
            },
          },
        },
        // Error Response
        ErrorResponse: {
          type: "object",
          properties: {
            success: {
              type: "boolean",
              example: false,
            },
            message: {
              type: "string",
              example: "An error occurred",
            },
            error: {
              type: "string",
              example: "Error details here",
            },
          },
        },
      },
      responses: {
        UnauthorizedError: {
          description: "Access token is missing or invalid",
          content: {
            "application/json": {
              schema: {
                $ref: "#/components/schemas/ErrorResponse",
              },
              example: {
                success: false,
                message: "Unauthorized",
                error: "No token provided",
              },
            },
          },
        },
        NotFoundError: {
          description: "Resource not found",
          content: {
            "application/json": {
              schema: {
                $ref: "#/components/schemas/ErrorResponse",
              },
            },
          },
        },
        ValidationError: {
          description: "Validation failed",
          content: {
            "application/json": {
              schema: {
                $ref: "#/components/schemas/ErrorResponse",
              },
            },
          },
        },
        RateLimitError: {
          description: "Too many requests",
          content: {
            "application/json": {
              schema: {
                $ref: "#/components/schemas/ErrorResponse",
              },
              example: {
                success: false,
                message: "Too many requests",
                error: "Rate limit exceeded. Please wait.",
              },
            },
          },
        },
      },
    },
  },
  // Path to the API docs
  apis: ["./src/routes/*.ts", "./src/controllers/*.ts"],
};

// Generate OpenAPI specification
const swaggerSpec = swaggerJsdoc(swaggerOptions);

/**
 * Setup Swagger documentation
 */
export const setupSwagger = (app: Application): void => {
  // Swagger UI options
  const swaggerUiOptions: swaggerUi.SwaggerUiOptions = {
    explorer: true,
    customCss: ".swagger-ui .topbar { display: none }",
    customSiteTitle: "Task Manager API Docs",
  };

  // Serve Swagger UI
  app.use(
    "/api/docs",
    swaggerUi.serve,
    swaggerUi.setup(swaggerSpec, swaggerUiOptions),
  );

  // Serve raw OpenAPI spec as JSON
  app.get("/api/docs.json", (req, res) => {
    res.setHeader("Content-Type", "application/json");
    res.send(swaggerSpec);
  });

  console.log("ğŸ“š Swagger docs available at /api/docs");
};

export default swaggerSpec;
```

---

### STEP 11: Add JSDoc Comments to Routes

ğŸ“ **File:** `src/routes/taskRoutes.ts` (add JSDoc comments)

Add these comments above each route:

```typescript
/**
 * @swagger
 * /api/tasks:
 *   get:
 *     summary: Get all tasks
 *     description: Retrieve all tasks with optional filtering, sorting, and pagination
 *     tags: [Tasks]
 *     parameters:
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [pending, in-progress, completed]
 *         description: Filter by task status
 *       - in: query
 *         name: priority
 *         schema:
 *           type: string
 *           enum: [low, medium, high]
 *         description: Filter by task priority
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 *         description: Search in title and description
 *       - in: query
 *         name: sort_by
 *         schema:
 *           type: string
 *           enum: [created_at, updated_at, due_date, priority]
 *         description: Field to sort by
 *       - in: query
 *         name: order
 *         schema:
 *           type: string
 *           enum: [asc, desc]
 *         description: Sort order
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 100
 *         description: Number of results to return
 *       - in: query
 *         name: offset
 *         schema:
 *           type: integer
 *           minimum: 0
 *         description: Number of results to skip
 *     responses:
 *       200:
 *         description: List of tasks
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Task'
 *                 count:
 *                   type: integer
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 */
router.get("/", validateQueryParams, TaskController.getAllTasks);

/**
 * @swagger
 * /api/tasks/{id}:
 *   get:
 *     summary: Get task by ID
 *     description: Retrieve a single task by its UUID
 *     tags: [Tasks]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         description: Task UUID
 *     responses:
 *       200:
 *         description: Task details
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   $ref: '#/components/schemas/Task'
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       404:
 *         $ref: '#/components/responses/NotFoundError'
 */
router.get("/:id", validateTaskId, TaskController.getTaskById);

/**
 * @swagger
 * /api/tasks:
 *   post:
 *     summary: Create a new task
 *     description: Create a new task (requires authentication)
 *     tags: [Tasks]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateTaskDTO'
 *     responses:
 *       201:
 *         description: Task created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Task'
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       429:
 *         $ref: '#/components/responses/RateLimitError'
 */
router.post("/", authenticate, validateCreateTask, TaskController.createTask);
```

---

## PHASE 3: ESLINT & PRETTIER SETUP

---

### STEP 12: Install Linting Dependencies

```bash
npm install -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
npm install -D prettier eslint-config-prettier eslint-plugin-prettier
```

---

### STEP 13: Create ESLint Configuration

ğŸ“ **File:** `.eslintrc.json`

```json
{
  "root": true,
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": 2020,
    "sourceType": "module",
    "project": "./tsconfig.json"
  },
  "plugins": ["@typescript-eslint", "prettier"],
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking",
    "prettier"
  ],
  "env": {
    "node": true,
    "es2020": true,
    "jest": true
  },
  "rules": {
    // TypeScript specific rules
    "@typescript-eslint/explicit-function-return-type": "warn",
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-unused-vars": [
      "error",
      { "argsIgnorePattern": "^_" }
    ],
    "@typescript-eslint/prefer-nullish-coalescing": "error",
    "@typescript-eslint/prefer-optional-chain": "error",
    "@typescript-eslint/no-floating-promises": "error",

    // General rules
    "no-console": ["warn", { "allow": ["warn", "error"] }],
    "prefer-const": "error",
    "no-var": "error",
    "eqeqeq": ["error", "always"],
    "curly": ["error", "all"],

    // Prettier integration
    "prettier/prettier": "error"
  },
  "ignorePatterns": ["node_modules/", "dist/", "coverage/", "*.js"]
}
```

---

### STEP 14: Create Prettier Configuration

ğŸ“ **File:** `.prettierrc`

```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": false,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "always",
  "endOfLine": "auto"
}
```

ğŸ“ **File:** `.prettierignore`

```
node_modules/
dist/
coverage/
*.md
```

---

### STEP 15: Update package.json with Lint Scripts

```json
{
  "scripts": {
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\""
  }
}
```

---

## PHASE 4: USE ASYNCHANDLER IN CONTROLLERS

---

### STEP 16: Refactor Controllers with AsyncHandler

You created `asyncHandler` in `errorHandler.ts` but didn't use it. Here's how to use it:

ğŸ“ **File:** `src/controllers/taskController.ts` (Refactored)

```typescript
// =====================
// TASK CONTROLLER - Request Handlers
// =====================

import { Request, Response, NextFunction } from "express";
import {
  Task,
  CreateTaskDTO,
  UpdateTaskDTO,
  TaskQueryParams,
  ApiResponse,
} from "../interfaces/task.interface";
import * as TaskService from "../services/taskService";
import { asyncHandler } from "../middleware/errorHandler";

// ==========================================
// GET ALL TASKS
// ==========================================
// No try-catch needed! asyncHandler handles errors automatically

export const getAllTasks = asyncHandler(
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    const queryParams: TaskQueryParams = {
      status: req.query.status as any,
      priority: req.query.priority as any,
      search: req.query.search as string,
      sort_by: req.query.sort_by as string,
      order: req.query.order as "asc" | "desc",
      limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
      offset: req.query.offset
        ? parseInt(req.query.offset as string)
        : undefined,
    };

    const { data, error, count } = await TaskService.getAllTasks(queryParams);

    if (error) {
      const response: ApiResponse<null> = {
        success: false,
        message: "Failed to fetch tasks",
        error: error.message,
      };
      res.status(500).json(response);
      return;
    }

    const response: ApiResponse<Task[]> = {
      success: true,
      message: `Found ${data?.length || 0} task(s)`,
      data: data || [],
      count: count || 0,
    };

    res.status(200).json(response);
  },
);

// ==========================================
// GET TASK BY ID
// ==========================================

export const getTaskById = asyncHandler(
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    const { id } = req.params;

    const { data, error } = await TaskService.getTaskById(id);

    if (error) {
      const response: ApiResponse<null> = {
        success: false,
        message: "Failed to fetch task",
        error: error.message,
      };
      res.status(500).json(response);
      return;
    }

    if (!data) {
      const response: ApiResponse<null> = {
        success: false,
        message: "Task not found",
        error: `No task found with ID: ${id}`,
      };
      res.status(404).json(response);
      return;
    }

    const response: ApiResponse<Task> = {
      success: true,
      message: "Task retrieved successfully",
      data,
    };

    res.status(200).json(response);
  },
);

// ==========================================
// CREATE TASK
// ==========================================

export const createTask = asyncHandler(
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    const taskData: CreateTaskDTO = req.body;

    const { data, error } = await TaskService.createTask(taskData);

    if (error) {
      const response: ApiResponse<null> = {
        success: false,
        message: "Failed to create task",
        error: error.message,
      };
      res.status(500).json(response);
      return;
    }

    const response: ApiResponse<Task> = {
      success: true,
      message: "Task created successfully",
      data: data!,
    };

    res.status(201).json(response);
  },
);

// ==========================================
// UPDATE TASK
// ==========================================

export const updateTask = asyncHandler(
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    const { id } = req.params;
    const updates: UpdateTaskDTO = req.body;

    const { data, error } = await TaskService.updateTask(id, updates);

    if (error) {
      const response: ApiResponse<null> = {
        success: false,
        message: "Failed to update task",
        error: error.message,
      };
      res.status(500).json(response);
      return;
    }

    if (!data) {
      const response: ApiResponse<null> = {
        success: false,
        message: "Task not found",
        error: `No task found with ID: ${id}`,
      };
      res.status(404).json(response);
      return;
    }

    const response: ApiResponse<Task> = {
      success: true,
      message: "Task updated successfully",
      data,
    };

    res.status(200).json(response);
  },
);

// ==========================================
// DELETE TASK
// ==========================================

export const deleteTask = asyncHandler(
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    const { id } = req.params;

    const { data, error } = await TaskService.deleteTask(id);

    if (error) {
      const response: ApiResponse<null> = {
        success: false,
        message: "Failed to delete task",
        error: error.message,
      };
      res.status(500).json(response);
      return;
    }

    if (!data) {
      const response: ApiResponse<null> = {
        success: false,
        message: "Task not found",
        error: `No task found with ID: ${id}`,
      };
      res.status(404).json(response);
      return;
    }

    const response: ApiResponse<Task> = {
      success: true,
      message: "Task deleted successfully",
      data,
    };

    res.status(200).json(response);
  },
);

// ==========================================
// GET TASK STATS
// ==========================================

export const getTaskStats = asyncHandler(
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    const stats = await TaskService.getTaskStats();

    if (!stats) {
      const response: ApiResponse<null> = {
        success: false,
        message: "Failed to fetch task statistics",
        error: "Could not retrieve stats",
      };
      res.status(500).json(response);
      return;
    }

    const response: ApiResponse<typeof stats> = {
      success: true,
      message: "Task statistics retrieved successfully",
      data: stats,
    };

    res.status(200).json(response);
  },
);
```

### ğŸ’¡ Benefits of asyncHandler:

| Before (with try-catch)      | After (with asyncHandler)   |
| ---------------------------- | --------------------------- |
| 15+ lines per controller     | 10 lines per controller     |
| Manual error forwarding      | Automatic error forwarding  |
| Repetitive code              | Clean, DRY code             |
| Easy to forget `next(error)` | Never forget error handling |

---

# ğŸ§ª RUNNING TESTS

```bash
# Run all tests
npm test

# Run tests in watch mode (re-runs on file changes)
npm run test:watch

# Run with coverage report
npm run test:coverage

# Run only unit tests
npm run test:unit

# Run only integration tests
npm run test:integration
```

---

# ğŸ“Š Code Quality Checklist

| Feature               | Status | Command                    |
| --------------------- | ------ | -------------------------- |
| Unit Tests            | âœ…     | `npm run test:unit`        |
| Integration Tests     | âœ…     | `npm run test:integration` |
| Test Coverage         | âœ…     | `npm run test:coverage`    |
| Swagger Documentation | âœ…     | Visit `/api/docs`          |
| ESLint                | âœ…     | `npm run lint`             |
| Prettier              | âœ…     | `npm run format`           |
| AsyncHandler          | âœ…     | Cleaner controllers        |

---

# ğŸ‰ CONGRATULATIONS!

Your API now has:

- âœ… **Comprehensive Test Suite** with Jest & Supertest
- âœ… **Interactive API Documentation** with Swagger
- âœ… **Code Linting** with ESLint
- âœ… **Code Formatting** with Prettier
- âœ… **Clean Controllers** with asyncHandler

**Next Steps:** Move on to the Advanced Features Roadmap (User-specific tasks, Tags, Real-time updates)!
