# ğŸš€ Advanced Features - Complete Implementation Guide

## ğŸ“‹ Level 3: Enhance Your Task Manager

Add **advanced functionality** to take your API to the next level:

- **User-Specific Tasks** - Each user sees only their tasks
- **Tags/Categories** - Organize tasks with labels
- **Task Subtasks** - Create parent-child relationships
- **Due Date Notifications** - Email reminders
- **Supabase Real-time** - Live updates

**Time to Complete:** 5-6 hours

---

# ğŸ¯ Why These Features Matter?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FEATURE VALUE                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  ğŸ‘¤ USER-SPECIFIC TASKS:                                        â”‚
â”‚  â€¢ Multi-tenant application                                     â”‚
â”‚  â€¢ Data isolation & privacy                                     â”‚
â”‚  â€¢ Personalized experience                                      â”‚
â”‚                                                                  â”‚
â”‚  ğŸ·ï¸ TAGS/CATEGORIES:                                            â”‚
â”‚  â€¢ Flexible organization                                        â”‚
â”‚  â€¢ Filter tasks by context                                      â”‚
â”‚  â€¢ Many-to-many relationship practice                          â”‚
â”‚                                                                  â”‚
â”‚  ğŸ“‹ SUBTASKS:                                                   â”‚
â”‚  â€¢ Break down complex tasks                                     â”‚
â”‚  â€¢ Track progress granularly                                    â”‚
â”‚  â€¢ Self-referencing tables                                      â”‚
â”‚                                                                  â”‚
â”‚  ğŸ”” NOTIFICATIONS:                                              â”‚
â”‚  â€¢ Proactive reminders                                          â”‚
â”‚  â€¢ Email integration                                            â”‚
â”‚  â€¢ Background jobs                                              â”‚
â”‚                                                                  â”‚
â”‚  âš¡ REAL-TIME:                                                  â”‚
â”‚  â€¢ Instant updates                                              â”‚
â”‚  â€¢ WebSocket connections                                        â”‚
â”‚  â€¢ Collaborative features                                       â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ğŸ—ï¸ Updated Database Schema

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DATABASE SCHEMA                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      users       â”‚      â”‚      tasks       â”‚      â”‚       tags       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (UUID) PK     â”‚â”€â”€â”   â”‚ id (UUID) PK     â”‚   â”Œâ”€â”€â”‚ id (UUID) PK     â”‚
â”‚ email            â”‚  â”‚   â”‚ title            â”‚   â”‚  â”‚ name             â”‚
â”‚ created_at       â”‚  â”‚   â”‚ description      â”‚   â”‚  â”‚ color            â”‚
â”‚ ...              â”‚  â”‚   â”‚ status           â”‚   â”‚  â”‚ user_id (FK)     â”‚â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚ priority         â”‚   â”‚  â”‚ created_at       â”‚  â”‚
                      â”‚   â”‚ due_date         â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                      â”‚   â”‚ user_id (FK)     â”‚â—„â”€â”€â”˜                        â”‚
                      â””â”€â”€â–ºâ”‚ parent_id (FK)   â”‚â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
                          â”‚ created_at       â”‚  â”‚  â”‚    task_tags     â”‚   â”‚
                          â”‚ updated_at       â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚ task_id (FK)     â”‚â”€â”€â–ºâ”‚
                                    â–²           â”‚  â”‚ tag_id (FK)      â”‚â”€â”€â”€â”˜
                                    â”‚           â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  (self-reference
                                   for subtasks)
```

---

# ğŸ› ï¸ STEP-BY-STEP IMPLEMENTATION

---

## PHASE 1: USER-SPECIFIC TASKS

---

### STEP 1: Update Database Schema

Run this SQL in Supabase SQL Editor:

```sql
-- =============================================
-- ADD USER_ID TO TASKS TABLE
-- =============================================

-- Add user_id column to tasks (references auth.users)
ALTER TABLE tasks
ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

-- Create index for faster queries by user
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);

-- Update existing tasks to have a default user (optional - for testing)
-- UPDATE tasks SET user_id = 'your-test-user-uuid' WHERE user_id IS NULL;

-- =============================================
-- ENABLE ROW LEVEL SECURITY (RLS)
-- =============================================

-- Enable RLS on tasks table
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only see their own tasks
CREATE POLICY "Users can view own tasks"
ON tasks FOR SELECT
USING (auth.uid() = user_id);

-- Policy: Users can insert their own tasks
CREATE POLICY "Users can create own tasks"
ON tasks FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- Policy: Users can update their own tasks
CREATE POLICY "Users can update own tasks"
ON tasks FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Policy: Users can delete their own tasks
CREATE POLICY "Users can delete own tasks"
ON tasks FOR DELETE
USING (auth.uid() = user_id);
```

### ğŸ’¡ Row Level Security (RLS) Explained:

| Policy Type | Purpose                                           |
| ----------- | ------------------------------------------------- |
| `SELECT`    | Controls who can read data                        |
| `INSERT`    | Controls who can add data (WITH CHECK)            |
| `UPDATE`    | Controls who can modify data (USING + WITH CHECK) |
| `DELETE`    | Controls who can remove data                      |

---

### STEP 2: Update Task Interface

ğŸ“ **File:** `src/interfaces/task.interface.ts` (Update)

```typescript
// Add user_id to Task interface
export interface Task {
  id: string;
  title: string;
  description: string | null;
  status: TaskStatus;
  priority: Priority;
  due_date: string | null;
  user_id: string; // [NEW] Owner of the task
  parent_id: string | null; // [NEW] For subtasks (Phase 3)
  created_at: string;
  updated_at: string;
}

// Add user_id to CreateTaskDTO
export interface CreateTaskDTO {
  title: string;
  description?: string;
  priority?: Priority;
  due_date?: string;
  user_id?: string; // [NEW] Will be set from authenticated user
  parent_id?: string; // [NEW] Optional parent task
}
```

---

### STEP 3: Update Task Service to Include User ID

ğŸ“ **File:** `src/services/taskService.ts` (Update)

```typescript
// ============================================
// UPDATED TASK SERVICE - With User Filtering
// ============================================

import supabase from "../config/supabase";
import {
  Task,
  CreateTaskDTO,
  UpdateTaskDTO,
  TaskQueryParams,
} from "../interfaces/task.interface";

const TABLE_NAME = "tasks";

/**
 * Get all tasks for a specific user
 *
 * @param userId - The authenticated user's ID
 * @param params - Query parameters for filtering
 */
export const getAllTasks = async (
  userId: string,
  params: TaskQueryParams = {},
): Promise<{ data: Task[] | null; error: any; count: number | null }> => {
  // Start building query
  let query = supabase
    .from(TABLE_NAME)
    .select("*", { count: "exact" })
    .eq("user_id", userId); // [KEY] Filter by user_id

  // Apply additional filters
  if (params.status) {
    query = query.eq("status", params.status);
  }

  if (params.priority) {
    query = query.eq("priority", params.priority);
  }

  if (params.search) {
    query = query.or(
      `title.ilike.%${params.search}%,description.ilike.%${params.search}%`,
    );
  }

  // Apply sorting
  const sortColumn = params.sort_by || "created_at";
  const sortOrder = params.order === "asc";
  query = query.order(sortColumn, { ascending: sortOrder });

  // Apply pagination
  if (params.limit) {
    query = query.limit(params.limit);
  }

  if (params.offset) {
    query = query.range(
      params.offset,
      params.offset + ((params.limit || 10) - 1),
    );
  }

  const { data, error, count } = await query;
  return { data, error, count };
};

/**
 * Get single task by ID (only if owned by user)
 */
export const getTaskById = async (
  id: string,
  userId: string,
): Promise<{ data: Task | null; error: any }> => {
  const { data, error } = await supabase
    .from(TABLE_NAME)
    .select("*")
    .eq("id", id)
    .eq("user_id", userId) // [KEY] Ensure user owns this task
    .single();

  return { data, error };
};

/**
 * Create new task for a user
 */
export const createTask = async (
  taskData: CreateTaskDTO,
  userId: string,
): Promise<{ data: Task | null; error: any }> => {
  const insertData = {
    title: taskData.title,
    description: taskData.description || null,
    priority: taskData.priority || "medium",
    due_date: taskData.due_date || null,
    parent_id: taskData.parent_id || null,
    user_id: userId, // [KEY] Set owner
    status: "pending",
  };

  const { data, error } = await supabase
    .from(TABLE_NAME)
    .insert(insertData)
    .select()
    .single();

  return { data, error };
};

/**
 * Update task (only if owned by user)
 */
export const updateTask = async (
  id: string,
  userId: string,
  updates: UpdateTaskDTO,
): Promise<{ data: Task | null; error: any }> => {
  const updateData: Partial<Task> = {};

  if (updates.title !== undefined) updateData.title = updates.title;
  if (updates.description !== undefined)
    updateData.description = updates.description;
  if (updates.status !== undefined) updateData.status = updates.status;
  if (updates.priority !== undefined) updateData.priority = updates.priority;
  if (updates.due_date !== undefined) updateData.due_date = updates.due_date;

  const { data, error } = await supabase
    .from(TABLE_NAME)
    .update(updateData)
    .eq("id", id)
    .eq("user_id", userId) // [KEY] Ensure user owns this task
    .select()
    .single();

  return { data, error };
};

/**
 * Delete task (only if owned by user)
 */
export const deleteTask = async (
  id: string,
  userId: string,
): Promise<{ data: Task | null; error: any }> => {
  // First get the task to return it
  const { data: existingTask, error: fetchError } = await getTaskById(
    id,
    userId,
  );

  if (fetchError || !existingTask) {
    return { data: null, error: fetchError || { message: "Task not found" } };
  }

  const { error } = await supabase
    .from(TABLE_NAME)
    .delete()
    .eq("id", id)
    .eq("user_id", userId);

  if (error) {
    return { data: null, error };
  }

  return { data: existingTask, error: null };
};

/**
 * Get task statistics for a user
 */
export const getTaskStats = async (
  userId: string,
): Promise<{
  total: number;
  pending: number;
  inProgress: number;
  completed: number;
} | null> => {
  try {
    const { data, error } = await supabase
      .from(TABLE_NAME)
      .select("status")
      .eq("user_id", userId); // [KEY] Stats for user only

    if (error || !data) return null;

    const stats = {
      total: data.length,
      pending: data.filter((t) => t.status === "pending").length,
      inProgress: data.filter((t) => t.status === "in-progress").length,
      completed: data.filter((t) => t.status === "completed").length,
    };

    return stats;
  } catch {
    return null;
  }
};
```

---

### STEP 4: Update Task Controller

ğŸ“ **File:** `src/controllers/taskController.ts` (Update key parts)

```typescript
// =====================
// TASK CONTROLLER - With User Context
// =====================

import { Request, Response, NextFunction } from "express";
import * as TaskService from "../services/taskService";
import { asyncHandler } from "../middleware/errorHandler";

// GET ALL TASKS - For authenticated user
export const getAllTasks = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    // Get user ID from authenticated request
    const userId = req.user!.id; // [KEY] From auth middleware

    const queryParams = {
      status: req.query.status as any,
      priority: req.query.priority as any,
      search: req.query.search as string,
      sort_by: req.query.sort_by as string,
      order: req.query.order as "asc" | "desc",
      limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
      offset: req.query.offset
        ? parseInt(req.query.offset as string)
        : undefined,
    };

    // Pass userId to service
    const { data, error, count } = await TaskService.getAllTasks(
      userId,
      queryParams,
    );

    if (error) {
      res.status(500).json({
        success: false,
        message: "Failed to fetch tasks",
        error: error.message,
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: `Found ${data?.length || 0} task(s)`,
      data: data || [],
      count: count || 0,
    });
  },
);

// GET TASK BY ID - Only if owned by user
export const getTaskById = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user!.id;

    const { data, error } = await TaskService.getTaskById(id, userId);

    if (error) {
      res.status(500).json({
        success: false,
        message: "Failed to fetch task",
        error: error.message,
      });
      return;
    }

    if (!data) {
      res.status(404).json({
        success: false,
        message: "Task not found",
        error: `No task found with ID: ${id} for this user`,
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: "Task retrieved successfully",
      data,
    });
  },
);

// CREATE TASK - For authenticated user
export const createTask = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const userId = req.user!.id;
    const taskData = req.body;

    // Create task with user ID
    const { data, error } = await TaskService.createTask(taskData, userId);

    if (error) {
      res.status(500).json({
        success: false,
        message: "Failed to create task",
        error: error.message,
      });
      return;
    }

    res.status(201).json({
      success: true,
      message: "Task created successfully",
      data: data!,
    });
  },
);

// UPDATE TASK - Only if owned by user
export const updateTask = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user!.id;
    const updates = req.body;

    const { data, error } = await TaskService.updateTask(id, userId, updates);

    if (error) {
      res.status(500).json({
        success: false,
        message: "Failed to update task",
        error: error.message,
      });
      return;
    }

    if (!data) {
      res.status(404).json({
        success: false,
        message: "Task not found",
        error: `No task found with ID: ${id} for this user`,
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: "Task updated successfully",
      data,
    });
  },
);

// DELETE TASK - Only if owned by user
export const deleteTask = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user!.id;

    const { data, error } = await TaskService.deleteTask(id, userId);

    if (error) {
      res.status(500).json({
        success: false,
        message: "Failed to delete task",
        error: error.message,
      });
      return;
    }

    if (!data) {
      res.status(404).json({
        success: false,
        message: "Task not found",
        error: `No task found with ID: ${id} for this user`,
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: "Task deleted successfully",
      data,
    });
  },
);

// GET STATS - For authenticated user
export const getTaskStats = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const userId = req.user!.id;

    const stats = await TaskService.getTaskStats(userId);

    if (!stats) {
      res.status(500).json({
        success: false,
        message: "Failed to fetch statistics",
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: "Statistics retrieved successfully",
      data: stats,
    });
  },
);
```

---

### STEP 5: Update Task Routes to Require Authentication

ğŸ“ **File:** `src/routes/taskRoutes.ts` (Update)

```typescript
// =============================
// TASK ROUTES - All Protected
// =============================

import { Router } from "express";
import * as TaskController from "../controllers/taskController";
import {
  validateCreateTask,
  validateUpdateTask,
  validateTaskId,
  validateQueryParams,
} from "../middleware/validateTask";
import { authenticate } from "../middleware/authMiddleware";
import { createTaskLimiter } from "../config/rateLimiter";

const router = Router();

// ====================================
// ALL ROUTES NOW REQUIRE AUTHENTICATION
// ====================================

// Apply authentication to ALL routes
router.use(authenticate);

// GET /api/tasks/stats
router.get("/stats", TaskController.getTaskStats);

// GET /api/tasks
router.get("/", validateQueryParams, TaskController.getAllTasks);

// GET /api/tasks/:id
router.get("/:id", validateTaskId, TaskController.getTaskById);

// POST /api/tasks
router.post(
  "/",
  createTaskLimiter,
  validateCreateTask,
  TaskController.createTask,
);

// PUT /api/tasks/:id
router.put(
  "/:id",
  validateTaskId,
  validateUpdateTask,
  TaskController.updateTask,
);

// DELETE /api/tasks/:id
router.delete("/:id", validateTaskId, TaskController.deleteTask);

export default router;
```

---

## PHASE 2: TAGS/CATEGORIES SYSTEM

---

### STEP 6: Create Tags Table

Run this SQL in Supabase SQL Editor:

```sql
-- =============================================
-- CREATE TAGS TABLE
-- =============================================

CREATE TABLE IF NOT EXISTS tags (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(50) NOT NULL,
    color VARCHAR(7) DEFAULT '#6366f1',  -- Hex color code
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    -- Ensure unique tag names per user
    UNIQUE(name, user_id)
);

-- Create index for faster queries
CREATE INDEX IF NOT EXISTS idx_tags_user_id ON tags(user_id);

-- =============================================
-- CREATE TASK_TAGS JUNCTION TABLE
-- =============================================

CREATE TABLE IF NOT EXISTS task_tags (
    task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
    tag_id UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    -- Composite primary key
    PRIMARY KEY (task_id, tag_id)
);

-- Create indexes for faster joins
CREATE INDEX IF NOT EXISTS idx_task_tags_task_id ON task_tags(task_id);
CREATE INDEX IF NOT EXISTS idx_task_tags_tag_id ON task_tags(tag_id);

-- =============================================
-- ROW LEVEL SECURITY FOR TAGS
-- =============================================

ALTER TABLE tags ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own tags"
ON tags FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can create own tags"
ON tags FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own tags"
ON tags FOR UPDATE
USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own tags"
ON tags FOR DELETE
USING (auth.uid() = user_id);

-- =============================================
-- INSERT SAMPLE TAGS
-- =============================================

-- Note: Replace 'your-user-id' with actual user UUID
-- INSERT INTO tags (name, color, user_id) VALUES
--     ('Work', '#ef4444', 'your-user-id'),
--     ('Personal', '#22c55e', 'your-user-id'),
--     ('Urgent', '#f97316', 'your-user-id'),
--     ('Learning', '#3b82f6', 'your-user-id');
```

---

### STEP 7: Create Tag Interface

ğŸ“ **File:** `src/interfaces/tag.interface.ts` (New file)

```typescript
// ============================================
// TAG INTERFACE - TypeScript Type Definitions
// ============================================

/**
 * Tag entity from database
 */
export interface Tag {
  id: string;
  name: string;
  color: string;
  user_id: string;
  created_at: string;
}

/**
 * DTO for creating a new tag
 */
export interface CreateTagDTO {
  name: string;
  color?: string; // Optional, defaults to #6366f1
}

/**
 * DTO for updating a tag
 */
export interface UpdateTagDTO {
  name?: string;
  color?: string;
}

/**
 * Task with its associated tags
 */
export interface TaskWithTags {
  id: string;
  title: string;
  description: string | null;
  status: string;
  priority: string;
  due_date: string | null;
  user_id: string;
  created_at: string;
  updated_at: string;
  tags: Tag[]; // Array of associated tags
}

/**
 * API Response for tag operations
 */
export interface TagResponse<T> {
  success: boolean;
  message: string;
  data?: T;
  error?: string;
}
```

---

### STEP 8: Create Tag Service

ğŸ“ **File:** `src/services/tagService.ts` (New file)

```typescript
// ============================================
// TAG SERVICE - Database Operations
// ============================================

import supabase from "../config/supabase";
import { Tag, CreateTagDTO, UpdateTagDTO } from "../interfaces/tag.interface";

const TABLE_NAME = "tags";
const JUNCTION_TABLE = "task_tags";

/**
 * Get all tags for a user
 */
export const getAllTags = async (
  userId: string,
): Promise<{ data: Tag[] | null; error: any }> => {
  const { data, error } = await supabase
    .from(TABLE_NAME)
    .select("*")
    .eq("user_id", userId)
    .order("name");

  return { data, error };
};

/**
 * Get tag by ID
 */
export const getTagById = async (
  id: string,
  userId: string,
): Promise<{ data: Tag | null; error: any }> => {
  const { data, error } = await supabase
    .from(TABLE_NAME)
    .select("*")
    .eq("id", id)
    .eq("user_id", userId)
    .single();

  return { data, error };
};

/**
 * Create new tag
 */
export const createTag = async (
  tagData: CreateTagDTO,
  userId: string,
): Promise<{ data: Tag | null; error: any }> => {
  const insertData = {
    name: tagData.name.toLowerCase().trim(),
    color: tagData.color || "#6366f1",
    user_id: userId,
  };

  const { data, error } = await supabase
    .from(TABLE_NAME)
    .insert(insertData)
    .select()
    .single();

  return { data, error };
};

/**
 * Update tag
 */
export const updateTag = async (
  id: string,
  userId: string,
  updates: UpdateTagDTO,
): Promise<{ data: Tag | null; error: any }> => {
  const updateData: Partial<Tag> = {};

  if (updates.name !== undefined) {
    updateData.name = updates.name.toLowerCase().trim();
  }
  if (updates.color !== undefined) {
    updateData.color = updates.color;
  }

  const { data, error } = await supabase
    .from(TABLE_NAME)
    .update(updateData)
    .eq("id", id)
    .eq("user_id", userId)
    .select()
    .single();

  return { data, error };
};

/**
 * Delete tag
 */
export const deleteTag = async (
  id: string,
  userId: string,
): Promise<{ error: any }> => {
  const { error } = await supabase
    .from(TABLE_NAME)
    .delete()
    .eq("id", id)
    .eq("user_id", userId);

  return { error };
};

/**
 * Add tag to task
 */
export const addTagToTask = async (
  taskId: string,
  tagId: string,
): Promise<{ error: any }> => {
  const { error } = await supabase
    .from(JUNCTION_TABLE)
    .insert({ task_id: taskId, tag_id: tagId });

  return { error };
};

/**
 * Remove tag from task
 */
export const removeTagFromTask = async (
  taskId: string,
  tagId: string,
): Promise<{ error: any }> => {
  const { error } = await supabase
    .from(JUNCTION_TABLE)
    .delete()
    .eq("task_id", taskId)
    .eq("tag_id", tagId);

  return { error };
};

/**
 * Get all tags for a task
 */
export const getTagsForTask = async (
  taskId: string,
): Promise<{ data: Tag[] | null; error: any }> => {
  const { data, error } = await supabase
    .from(JUNCTION_TABLE)
    .select(
      `
      tag_id,
      tags (*)
    `,
    )
    .eq("task_id", taskId);

  if (error) {
    return { data: null, error };
  }

  // Extract tags from the joined result
  const tags = data?.map((item: any) => item.tags) || [];
  return { data: tags, error: null };
};

/**
 * Get all tasks for a tag
 */
export const getTasksForTag = async (
  tagId: string,
  userId: string,
): Promise<{ data: any[] | null; error: any }> => {
  const { data, error } = await supabase
    .from(JUNCTION_TABLE)
    .select(
      `
      task_id,
      tasks (*)
    `,
    )
    .eq("tag_id", tagId);

  if (error) {
    return { data: null, error };
  }

  // Filter tasks by user and extract
  const tasks =
    data
      ?.map((item: any) => item.tasks)
      .filter((task: any) => task.user_id === userId) || [];

  return { data: tasks, error: null };
};

/**
 * Set tags for a task (replaces existing tags)
 */
export const setTaskTags = async (
  taskId: string,
  tagIds: string[],
): Promise<{ error: any }> => {
  // First, remove all existing tags
  const { error: deleteError } = await supabase
    .from(JUNCTION_TABLE)
    .delete()
    .eq("task_id", taskId);

  if (deleteError) {
    return { error: deleteError };
  }

  // Then add new tags
  if (tagIds.length > 0) {
    const insertData = tagIds.map((tagId) => ({
      task_id: taskId,
      tag_id: tagId,
    }));

    const { error: insertError } = await supabase
      .from(JUNCTION_TABLE)
      .insert(insertData);

    if (insertError) {
      return { error: insertError };
    }
  }

  return { error: null };
};
```

---

### STEP 9: Create Tag Controller

ğŸ“ **File:** `src/controllers/tagController.ts` (New file)

```typescript
// ============================================
// TAG CONTROLLER - Request Handlers
// ============================================

import { Request, Response } from "express";
import * as TagService from "../services/tagService";
import { asyncHandler } from "../middleware/errorHandler";
import { CreateTagDTO, UpdateTagDTO } from "../interfaces/tag.interface";

// GET ALL TAGS
export const getAllTags = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const userId = req.user!.id;

    const { data, error } = await TagService.getAllTags(userId);

    if (error) {
      res.status(500).json({
        success: false,
        message: "Failed to fetch tags",
        error: error.message,
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: `Found ${data?.length || 0} tag(s)`,
      data: data || [],
    });
  },
);

// GET TAG BY ID
export const getTagById = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user!.id;

    const { data, error } = await TagService.getTagById(id, userId);

    if (error || !data) {
      res.status(404).json({
        success: false,
        message: "Tag not found",
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: "Tag retrieved successfully",
      data,
    });
  },
);

// CREATE TAG
export const createTag = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const userId = req.user!.id;
    const tagData: CreateTagDTO = req.body;

    const { data, error } = await TagService.createTag(tagData, userId);

    if (error) {
      // Check for duplicate tag error
      if (error.code === "23505") {
        res.status(409).json({
          success: false,
          message: "Tag already exists",
          error: `A tag named "${tagData.name}" already exists`,
        });
        return;
      }

      res.status(500).json({
        success: false,
        message: "Failed to create tag",
        error: error.message,
      });
      return;
    }

    res.status(201).json({
      success: true,
      message: "Tag created successfully",
      data,
    });
  },
);

// UPDATE TAG
export const updateTag = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user!.id;
    const updates: UpdateTagDTO = req.body;

    const { data, error } = await TagService.updateTag(id, userId, updates);

    if (error || !data) {
      res.status(404).json({
        success: false,
        message: "Tag not found",
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: "Tag updated successfully",
      data,
    });
  },
);

// DELETE TAG
export const deleteTag = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user!.id;

    const { error } = await TagService.deleteTag(id, userId);

    if (error) {
      res.status(500).json({
        success: false,
        message: "Failed to delete tag",
        error: error.message,
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: "Tag deleted successfully",
    });
  },
);

// ADD TAG TO TASK
export const addTagToTask = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const { taskId, tagId } = req.params;

    const { error } = await TagService.addTagToTask(taskId, tagId);

    if (error) {
      res.status(500).json({
        success: false,
        message: "Failed to add tag to task",
        error: error.message,
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: "Tag added to task successfully",
    });
  },
);

// REMOVE TAG FROM TASK
export const removeTagFromTask = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const { taskId, tagId } = req.params;

    const { error } = await TagService.removeTagFromTask(taskId, tagId);

    if (error) {
      res.status(500).json({
        success: false,
        message: "Failed to remove tag from task",
        error: error.message,
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: "Tag removed from task successfully",
    });
  },
);

// GET TAGS FOR TASK
export const getTagsForTask = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const { taskId } = req.params;

    const { data, error } = await TagService.getTagsForTask(taskId);

    if (error) {
      res.status(500).json({
        success: false,
        message: "Failed to fetch tags",
        error: error.message,
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: `Found ${data?.length || 0} tag(s)`,
      data: data || [],
    });
  },
);

// GET TASKS FOR TAG
export const getTasksForTag = asyncHandler(
  async (req: Request, res: Response): Promise<void> => {
    const { tagId } = req.params;
    const userId = req.user!.id;

    const { data, error } = await TagService.getTasksForTag(tagId, userId);

    if (error) {
      res.status(500).json({
        success: false,
        message: "Failed to fetch tasks",
        error: error.message,
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: `Found ${data?.length || 0} task(s)`,
      data: data || [],
    });
  },
);
```

---

### STEP 10: Create Tag Routes

ğŸ“ **File:** `src/routes/tagRoutes.ts` (New file)

```typescript
// =============================
// TAG ROUTES - API Endpoints
// =============================

import { Router } from "express";
import * as TagController from "../controllers/tagController";
import { authenticate } from "../middleware/authMiddleware";

const router = Router();

// All routes require authentication
router.use(authenticate);

// ====================================
// TAG CRUD ROUTES
// ====================================

// GET /api/tags - Get all tags
router.get("/", TagController.getAllTags);

// GET /api/tags/:id - Get tag by ID
router.get("/:id", TagController.getTagById);

// POST /api/tags - Create new tag
router.post("/", TagController.createTag);

// PUT /api/tags/:id - Update tag
router.put("/:id", TagController.updateTag);

// DELETE /api/tags/:id - Delete tag
router.delete("/:id", TagController.deleteTag);

// ====================================
// TASK-TAG RELATIONSHIP ROUTES
// ====================================

// GET /api/tags/:tagId/tasks - Get all tasks for a tag
router.get("/:tagId/tasks", TagController.getTasksForTag);

// POST /api/tags/:tagId/tasks/:taskId - Add tag to task
router.post("/:tagId/tasks/:taskId", TagController.addTagToTask);

// DELETE /api/tags/:tagId/tasks/:taskId - Remove tag from task
router.delete("/:tagId/tasks/:taskId", TagController.removeTagFromTask);

export default router;
```

---

### STEP 11: Update app.ts to Include Tag Routes

ğŸ“ **File:** `src/app.ts` (Add import and route)

```typescript
// Add import
import tagRoutes from "./routes/tagRoutes";

// Add route (after auth routes)
app.use("/api/tags", tagRoutes);
```

---

## PHASE 3: SUBTASKS (Self-Referencing)

---

### STEP 12: Update Tasks Table for Subtasks

Run this SQL in Supabase:

```sql
-- =============================================
-- ADD PARENT_ID FOR SUBTASKS
-- =============================================

-- Add parent_id column (self-referencing)
ALTER TABLE tasks
ADD COLUMN IF NOT EXISTS parent_id UUID REFERENCES tasks(id) ON DELETE CASCADE;

-- Create index for faster subtask queries
CREATE INDEX IF NOT EXISTS idx_tasks_parent_id ON tasks(parent_id);

-- =============================================
-- HELPER FUNCTIONS
-- =============================================

-- Function to get task with all subtasks (recursive)
CREATE OR REPLACE FUNCTION get_task_with_subtasks(task_uuid UUID)
RETURNS TABLE (
    id UUID,
    title VARCHAR,
    description TEXT,
    status VARCHAR,
    priority VARCHAR,
    due_date TIMESTAMP WITH TIME ZONE,
    user_id UUID,
    parent_id UUID,
    depth INT,
    created_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE task_tree AS (
        -- Base case: the root task
        SELECT
            t.id, t.title, t.description, t.status, t.priority,
            t.due_date, t.user_id, t.parent_id, 0 AS depth,
            t.created_at, t.updated_at
        FROM tasks t
        WHERE t.id = task_uuid

        UNION ALL

        -- Recursive case: subtasks
        SELECT
            t.id, t.title, t.description, t.status, t.priority,
            t.due_date, t.user_id, t.parent_id, tt.depth + 1,
            t.created_at, t.updated_at
        FROM tasks t
        JOIN task_tree tt ON t.parent_id = tt.id
    )
    SELECT * FROM task_tree ORDER BY depth, created_at;
END;
$$ LANGUAGE plpgsql;
```

---

### STEP 13: Add Subtask Methods to Task Service

ğŸ“ **File:** `src/services/taskService.ts` (Add these methods)

```typescript
/**
 * Get subtasks for a task
 */
export const getSubtasks = async (
  parentId: string,
  userId: string,
): Promise<{ data: Task[] | null; error: any }> => {
  const { data, error } = await supabase
    .from(TABLE_NAME)
    .select("*")
    .eq("parent_id", parentId)
    .eq("user_id", userId)
    .order("created_at");

  return { data, error };
};

/**
 * Create subtask
 */
export const createSubtask = async (
  parentId: string,
  taskData: CreateTaskDTO,
  userId: string,
): Promise<{ data: Task | null; error: any }> => {
  // Verify parent task exists and belongs to user
  const { data: parentTask, error: parentError } = await getTaskById(
    parentId,
    userId,
  );

  if (parentError || !parentTask) {
    return { data: null, error: { message: "Parent task not found" } };
  }

  // Create subtask with parent_id
  const insertData = {
    title: taskData.title,
    description: taskData.description || null,
    priority: taskData.priority || parentTask.priority, // Inherit priority
    due_date: taskData.due_date || parentTask.due_date, // Inherit due date
    parent_id: parentId,
    user_id: userId,
    status: "pending",
  };

  const { data, error } = await supabase
    .from(TABLE_NAME)
    .insert(insertData)
    .select()
    .single();

  return { data, error };
};

/**
 * Get task with all subtasks (using recursive function)
 */
export const getTaskWithSubtasks = async (
  taskId: string,
  userId: string,
): Promise<{ data: any | null; error: any }> => {
  // Get the main task
  const { data: mainTask, error: mainError } = await getTaskById(
    taskId,
    userId,
  );

  if (mainError || !mainTask) {
    return { data: null, error: mainError || { message: "Task not found" } };
  }

  // Get all subtasks recursively
  const { data: subtasks, error: subtaskError } = await supabase.rpc(
    "get_task_with_subtasks",
    { task_uuid: taskId },
  );

  if (subtaskError) {
    return { data: null, error: subtaskError };
  }

  // Build tree structure
  const taskMap = new Map();
  const rootTask = subtasks.find((t: any) => t.id === taskId);

  subtasks.forEach((task: any) => {
    taskMap.set(task.id, { ...task, subtasks: [] });
  });

  subtasks.forEach((task: any) => {
    if (task.parent_id && task.parent_id !== taskId) {
      const parent = taskMap.get(task.parent_id);
      if (parent) {
        parent.subtasks.push(taskMap.get(task.id));
      }
    }
  });

  const result = taskMap.get(taskId);
  result.subtasks = subtasks
    .filter((t: any) => t.parent_id === taskId)
    .map((t: any) => taskMap.get(t.id));

  return { data: result, error: null };
};

/**
 * Calculate task completion percentage based on subtasks
 */
export const getTaskProgress = async (
  taskId: string,
  userId: string,
): Promise<{
  data: { total: number; completed: number; percentage: number } | null;
  error: any;
}> => {
  const { data: subtasks, error } = await getSubtasks(taskId, userId);

  if (error) {
    return { data: null, error };
  }

  if (!subtasks || subtasks.length === 0) {
    return {
      data: { total: 0, completed: 0, percentage: 0 },
      error: null,
    };
  }

  const total = subtasks.length;
  const completed = subtasks.filter((t) => t.status === "completed").length;
  const percentage = Math.round((completed / total) * 100);

  return { data: { total, completed, percentage }, error: null };
};
```

---

## PHASE 4: SUPABASE REAL-TIME

---

### STEP 14: Understanding Supabase Real-time

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    REAL-TIME FLOW                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   1. Client subscribes to channel                               â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     Subscribe       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  Client  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚  Supabase Realtime   â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                             â”‚                    â”‚
â”‚   2. Database changes trigger events        â”‚                    â”‚
â”‚                                             â–¼                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  tasks table         â”‚ â”€â”€â”€â”€â”€â”€â–º â”‚  Realtime Server     â”‚    â”‚
â”‚   â”‚  INSERT/UPDATE/DELETE â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚                    â”‚
â”‚                                             â”‚                    â”‚
â”‚   3. Event pushed to subscribed clients     â”‚                    â”‚
â”‚                                             â–¼                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     Event           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  Client  â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚  WebSocket Push      â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### STEP 15: Enable Real-time for Tasks Table

Run this SQL in Supabase:

```sql
-- Enable realtime for tasks table
ALTER PUBLICATION supabase_realtime ADD TABLE tasks;

-- Enable realtime for tags table
ALTER PUBLICATION supabase_realtime ADD TABLE tags;

-- Enable realtime for task_tags table
ALTER PUBLICATION supabase_realtime ADD TABLE task_tags;
```

---

### STEP 16: Create Real-time Service

ğŸ“ **File:** `src/services/realtimeService.ts` (New file)

```typescript
// ============================================
// REAL-TIME SERVICE - Supabase Subscriptions
// ============================================

import supabase from "../config/supabase";
import {
  RealtimeChannel,
  RealtimePostgresChangesPayload,
} from "@supabase/supabase-js";
import { Task } from "../interfaces/task.interface";

type TaskChangeCallback = (
  eventType: "INSERT" | "UPDATE" | "DELETE",
  task: Task | null,
  oldTask?: Task,
) => void;

/**
 * Subscribe to task changes for a specific user
 *
 * @param userId - User ID to filter changes
 * @param callback - Function to call when changes occur
 * @returns Cleanup function to unsubscribe
 */
export const subscribeToTaskChanges = (
  userId: string,
  callback: TaskChangeCallback,
): (() => void) => {
  const channel: RealtimeChannel = supabase
    .channel(`tasks:user:${userId}`)
    .on(
      "postgres_changes",
      {
        event: "*", // Listen to all events (INSERT, UPDATE, DELETE)
        schema: "public",
        table: "tasks",
        filter: `user_id=eq.${userId}`, // Only this user's tasks
      },
      (payload: RealtimePostgresChangesPayload<Task>) => {
        const eventType = payload.eventType as "INSERT" | "UPDATE" | "DELETE";
        const newTask = payload.new as Task | null;
        const oldTask = payload.old as Task | undefined;

        console.log(`ğŸ“¡ Real-time event: ${eventType}`, {
          new: newTask?.id,
          old: oldTask?.id,
        });

        callback(eventType, newTask, oldTask);
      },
    )
    .subscribe((status) => {
      console.log(`ğŸ“¡ Subscription status: ${status}`);
    });

  // Return cleanup function
  return () => {
    console.log("ğŸ“¡ Unsubscribing from task changes");
    supabase.removeChannel(channel);
  };
};

/**
 * Subscribe to tag changes for a user
 */
export const subscribeToTagChanges = (
  userId: string,
  callback: (eventType: string, tag: any) => void,
): (() => void) => {
  const channel = supabase
    .channel(`tags:user:${userId}`)
    .on(
      "postgres_changes",
      {
        event: "*",
        schema: "public",
        table: "tags",
        filter: `user_id=eq.${userId}`,
      },
      (payload) => {
        callback(payload.eventType, payload.new || payload.old);
      },
    )
    .subscribe();

  return () => {
    supabase.removeChannel(channel);
  };
};

/**
 * Example: Real-time task counter
 * Useful for dashboard widgets
 */
export const createTaskCounter = (
  userId: string,
  onCountChange: (counts: { pending: number; completed: number }) => void,
): (() => void) => {
  let counts = { pending: 0, completed: 0 };

  // Initial count
  const fetchInitialCounts = async () => {
    const { data } = await supabase
      .from("tasks")
      .select("status")
      .eq("user_id", userId);

    if (data) {
      counts = {
        pending: data.filter((t) => t.status !== "completed").length,
        completed: data.filter((t) => t.status === "completed").length,
      };
      onCountChange(counts);
    }
  };

  fetchInitialCounts();

  // Subscribe to changes
  return subscribeToTaskChanges(userId, (eventType, task, oldTask) => {
    switch (eventType) {
      case "INSERT":
        if (task?.status === "completed") {
          counts.completed++;
        } else {
          counts.pending++;
        }
        break;

      case "DELETE":
        if (oldTask?.status === "completed") {
          counts.completed--;
        } else {
          counts.pending--;
        }
        break;

      case "UPDATE":
        if (oldTask?.status !== "completed" && task?.status === "completed") {
          counts.pending--;
          counts.completed++;
        } else if (
          oldTask?.status === "completed" &&
          task?.status !== "completed"
        ) {
          counts.completed--;
          counts.pending++;
        }
        break;
    }

    onCountChange(counts);
  });
};
```

---

### STEP 17: Create Real-time WebSocket Endpoint

ğŸ“ **File:** `src/routes/realtimeRoutes.ts` (New file)

For real-time functionality in a REST API context, you typically use Server-Sent Events (SSE):

```typescript
// ============================================
// REAL-TIME ROUTES - Server-Sent Events
// ============================================

import { Router, Request, Response } from "express";
import { authenticate } from "../middleware/authMiddleware";
import { subscribeToTaskChanges } from "../services/realtimeService";

const router = Router();

// Apply authentication
router.use(authenticate);

/**
 * GET /api/realtime/tasks
 *
 * Server-Sent Events endpoint for real-time task updates
 * Client connects and receives updates as they happen
 */
router.get("/tasks", (req: Request, res: Response) => {
  const userId = req.user!.id;

  // Set headers for SSE
  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Cache-Control", "no-cache");
  res.setHeader("Connection", "keep-alive");
  res.setHeader("X-Accel-Buffering", "no"); // For nginx

  // Send initial connection message
  res.write(`data: ${JSON.stringify({ type: "connected", userId })}\n\n`);

  console.log(`ğŸ“¡ SSE: Client connected for user ${userId}`);

  // Subscribe to task changes
  const unsubscribe = subscribeToTaskChanges(
    userId,
    (eventType, task, oldTask) => {
      const eventData = {
        type: eventType.toLowerCase(),
        task: task,
        oldTask: oldTask,
        timestamp: new Date().toISOString(),
      };

      res.write(`data: ${JSON.stringify(eventData)}\n\n`);
    },
  );

  // Handle client disconnect
  req.on("close", () => {
    console.log(`ğŸ“¡ SSE: Client disconnected for user ${userId}`);
    unsubscribe();
  });

  // Send heartbeat every 30 seconds to keep connection alive
  const heartbeat = setInterval(() => {
    res.write(`data: ${JSON.stringify({ type: "heartbeat" })}\n\n`);
  }, 30000);

  req.on("close", () => {
    clearInterval(heartbeat);
  });
});

export default router;
```

---

### STEP 18: Update app.ts for Real-time Routes

```typescript
// Add import
import realtimeRoutes from "./routes/realtimeRoutes";

// Add route
app.use("/api/realtime", realtimeRoutes);
```

---

### STEP 19: Client-Side Usage Example

For a frontend application, here's how to connect to the SSE endpoint:

```javascript
// Frontend JavaScript/TypeScript

class TaskRealtimeClient {
  constructor(baseUrl, accessToken) {
    this.baseUrl = baseUrl;
    this.accessToken = accessToken;
    this.eventSource = null;
    this.listeners = new Map();
  }

  connect() {
    // Note: EventSource doesn't support custom headers
    // You'd need to use a different approach or pass token in URL
    const url = `${this.baseUrl}/api/realtime/tasks?token=${this.accessToken}`;

    this.eventSource = new EventSource(url);

    this.eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleEvent(data);
    };

    this.eventSource.onerror = (error) => {
      console.error("SSE Error:", error);
      // Reconnect logic here
    };
  }

  handleEvent(data) {
    const { type, task, oldTask } = data;

    switch (type) {
      case "connected":
        console.log("Connected to real-time updates");
        break;

      case "insert":
        this.notifyListeners("taskCreated", task);
        break;

      case "update":
        this.notifyListeners("taskUpdated", { task, oldTask });
        break;

      case "delete":
        this.notifyListeners("taskDeleted", oldTask);
        break;

      case "heartbeat":
        // Connection still alive
        break;
    }
  }

  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }

  notifyListeners(event, data) {
    const callbacks = this.listeners.get(event) || [];
    callbacks.forEach((cb) => cb(data));
  }

  disconnect() {
    if (this.eventSource) {
      this.eventSource.close();
    }
  }
}

// Usage
const client = new TaskRealtimeClient("http://localhost:3000", accessToken);

client.on("taskCreated", (task) => {
  console.log("New task created:", task);
  // Update UI
});

client.on("taskUpdated", ({ task, oldTask }) => {
  console.log("Task updated:", task);
  // Update UI
});

client.on("taskDeleted", (task) => {
  console.log("Task deleted:", task);
  // Update UI
});

client.connect();
```

---

# ğŸ“Š API Endpoints Summary

## Task Endpoints (Updated)

| Method | Endpoint                  | Description             | Auth |
| ------ | ------------------------- | ----------------------- | ---- |
| GET    | `/api/tasks`              | Get user's tasks        | âœ…   |
| GET    | `/api/tasks/:id`          | Get task (if owned)     | âœ…   |
| GET    | `/api/tasks/:id/subtasks` | Get subtasks            | âœ…   |
| GET    | `/api/tasks/:id/progress` | Get completion progress | âœ…   |
| POST   | `/api/tasks`              | Create task             | âœ…   |
| POST   | `/api/tasks/:id/subtasks` | Create subtask          | âœ…   |
| PUT    | `/api/tasks/:id`          | Update task             | âœ…   |
| DELETE | `/api/tasks/:id`          | Delete task             | âœ…   |

## Tag Endpoints (New)

| Method | Endpoint                         | Description          | Auth |
| ------ | -------------------------------- | -------------------- | ---- |
| GET    | `/api/tags`                      | Get user's tags      | âœ…   |
| GET    | `/api/tags/:id`                  | Get tag by ID        | âœ…   |
| GET    | `/api/tags/:tagId/tasks`         | Get tasks with tag   | âœ…   |
| POST   | `/api/tags`                      | Create tag           | âœ…   |
| POST   | `/api/tags/:tagId/tasks/:taskId` | Add tag to task      | âœ…   |
| PUT    | `/api/tags/:id`                  | Update tag           | âœ…   |
| DELETE | `/api/tags/:id`                  | Delete tag           | âœ…   |
| DELETE | `/api/tags/:tagId/tasks/:taskId` | Remove tag from task | âœ…   |

## Real-time Endpoints (New)

| Method | Endpoint              | Description          | Auth |
| ------ | --------------------- | -------------------- | ---- |
| GET    | `/api/realtime/tasks` | SSE stream for tasks | âœ…   |

---

# ğŸ‰ CONGRATULATIONS!

Your API now has:

- âœ… **User-Specific Tasks** - Complete data isolation
- âœ… **Tags System** - Flexible organization with many-to-many
- âœ… **Subtasks** - Hierarchical task structure
- âœ… **Real-time Updates** - Live data via SSE

**Next Steps:** Move on to the Production Deployment Roadmap (Docker, CI/CD, Monitoring)!
