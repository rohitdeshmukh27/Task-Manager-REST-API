# üöÄ Production Deployment - Complete Guide

## üìã Level 4: Deploy Your API to Production

Take your Task Manager API from development to **production-ready deployment**:

- **Docker** - Containerize your application
- **CI/CD** - Automated testing & deployment with GitHub Actions
- **Deployment** - Deploy to Railway/Render
- **Monitoring** - Health checks & error tracking

**Time to Complete:** 4-5 hours

---

# üéØ Why Production Deployment Matters?

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    PRODUCTION BENEFITS                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                  ‚îÇ
‚îÇ  üê≥ DOCKER:                                                     ‚îÇ
‚îÇ  ‚Ä¢ Consistent environments (dev = prod)                         ‚îÇ
‚îÇ  ‚Ä¢ Easy deployment to any platform                              ‚îÇ
‚îÇ  ‚Ä¢ Isolated dependencies                                        ‚îÇ
‚îÇ  ‚Ä¢ Scalable architecture                                        ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  üîÑ CI/CD:                                                      ‚îÇ
‚îÇ  ‚Ä¢ Automated testing on every push                              ‚îÇ
‚îÇ  ‚Ä¢ Catch bugs before deployment                                 ‚îÇ
‚îÇ  ‚Ä¢ Consistent build process                                     ‚îÇ
‚îÇ  ‚Ä¢ Zero-downtime deployments                                    ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚òÅÔ∏è CLOUD DEPLOYMENT:                                           ‚îÇ
‚îÇ  ‚Ä¢ 24/7 availability                                            ‚îÇ
‚îÇ  ‚Ä¢ Auto-scaling                                                 ‚îÇ
‚îÇ  ‚Ä¢ SSL certificates                                             ‚îÇ
‚îÇ  ‚Ä¢ Custom domains                                               ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  üìä MONITORING:                                                 ‚îÇ
‚îÇ  ‚Ä¢ Proactive error detection                                    ‚îÇ
‚îÇ  ‚Ä¢ Performance metrics                                          ‚îÇ
‚îÇ  ‚Ä¢ Usage analytics                                              ‚îÇ
‚îÇ  ‚Ä¢ Incident alerts                                              ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

# üèóÔ∏è Updated Project Structure

```
task-manager-api/
‚îÇ
‚îú‚îÄ‚îÄ üìÅ .github/
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ workflows/
‚îÇ       ‚îú‚îÄ‚îÄ ci.yml                    # [NEW] CI pipeline
‚îÇ       ‚îî‚îÄ‚îÄ deploy.yml                # [NEW] CD pipeline
‚îÇ
‚îú‚îÄ‚îÄ üìÅ src/
‚îÇ   ‚îî‚îÄ‚îÄ ... (existing files)
‚îÇ
‚îú‚îÄ‚îÄ üìÅ tests/
‚îÇ   ‚îî‚îÄ‚îÄ ... (existing files)
‚îÇ
‚îú‚îÄ‚îÄ Dockerfile                        # [NEW] Container definition
‚îú‚îÄ‚îÄ docker-compose.yml                # [NEW] Local development
‚îú‚îÄ‚îÄ docker-compose.prod.yml           # [NEW] Production config
‚îú‚îÄ‚îÄ .dockerignore                     # [NEW] Docker ignore file
‚îÇ
‚îú‚îÄ‚îÄ .env                              # Local environment
‚îú‚îÄ‚îÄ .env.production                   # [NEW] Production variables
‚îÇ
‚îî‚îÄ‚îÄ package.json                      # Updated scripts
```

---

# üõ†Ô∏è STEP-BY-STEP IMPLEMENTATION

---

## PHASE 1: DOCKER CONTAINERIZATION

---

### STEP 1: Install Docker

**Windows:**

1. Download Docker Desktop from https://docker.com
2. Install and restart computer
3. Verify: `docker --version`

**macOS:**

```bash
brew install --cask docker
```

**Linux (Ubuntu):**

```bash
sudo apt update
sudo apt install docker.io docker-compose
sudo usermod -aG docker $USER
```

---

### STEP 2: Create Dockerfile

üìÅ **File:** `Dockerfile`

```dockerfile
# ============================================
# TASK MANAGER API - Production Dockerfile
# ============================================

# ==========================================
# Stage 1: Build Stage
# ==========================================
FROM node:20-alpine AS builder

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install ALL dependencies (including devDependencies for build)
RUN npm ci

# Copy source code
COPY . .

# Build TypeScript to JavaScript
RUN npm run build

# Remove dev dependencies
RUN npm prune --production

# ==========================================
# Stage 2: Production Stage
# ==========================================
FROM node:20-alpine AS production

# Create non-root user for security
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# Set working directory
WORKDIR /app

# Copy built files from builder stage
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/package.json ./

# Set environment variables
ENV NODE_ENV=production
ENV PORT=3000

# Switch to non-root user
USER nodejs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:3000/ || exit 1

# Start the application
CMD ["node", "dist/app.js"]
```

### üí° Multi-Stage Build Benefits:

| Stage        | Purpose                  | Size Impact |
| ------------ | ------------------------ | ----------- |
| `builder`    | Install deps, compile TS | ~500MB      |
| `production` | Only runtime files       | ~150MB      |

---

### STEP 3: Create .dockerignore

üìÅ **File:** `.dockerignore`

```dockerignore
# Dependencies
node_modules
npm-debug.log

# Build output (we build in Docker)
dist

# Environment files (injected at runtime)
.env
.env.*
!.env.example

# Development files
.git
.gitignore
.vscode
*.md
docs/

# Test files
tests/
coverage/
jest.config.js

# IDE
.idea
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db
```

---

### STEP 4: Create Docker Compose for Development

üìÅ **File:** `docker-compose.yml`

```yaml
# ============================================
# DOCKER COMPOSE - Development Environment
# ============================================

version: "3.8"

services:
  # Task Manager API
  api:
    build:
      context: .
      dockerfile: Dockerfile
      target: builder # Use builder stage for dev
    container_name: task-manager-api-dev
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - PORT=3000
    env_file:
      - .env
    volumes:
      # Mount source code for hot-reload
      - ./src:/app/src:ro
      - ./package.json:/app/package.json:ro
    command: npm run dev
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # Optional: Redis for caching (future use)
  # redis:
  #   image: redis:alpine
  #   container_name: task-manager-redis
  #   ports:
  #     - "6379:6379"
  #   restart: unless-stopped

networks:
  default:
    name: task-manager-network
```

---

### STEP 5: Create Docker Compose for Production

üìÅ **File:** `docker-compose.prod.yml`

```yaml
# ============================================
# DOCKER COMPOSE - Production Environment
# ============================================

version: "3.8"

services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: task-manager-api
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - PORT=3000
    env_file:
      - .env.production
    restart: always
    deploy:
      resources:
        limits:
          cpus: "1"
          memory: 512M
        reservations:
          cpus: "0.25"
          memory: 128M
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

networks:
  default:
    name: task-manager-prod-network
```

---

### STEP 6: Update package.json with Docker Scripts

```json
{
  "scripts": {
    "start": "node dist/app.js",
    "dev": "nodemon src/app.ts",
    "build": "tsc",
    "test": "jest",

    "docker:build": "docker build -t task-manager-api .",
    "docker:run": "docker run -p 3000:3000 --env-file .env task-manager-api",
    "docker:dev": "docker-compose up --build",
    "docker:dev:down": "docker-compose down",
    "docker:prod": "docker-compose -f docker-compose.prod.yml up --build -d",
    "docker:prod:down": "docker-compose -f docker-compose.prod.yml down",
    "docker:logs": "docker-compose logs -f",
    "docker:clean": "docker system prune -af"
  }
}
```

---

### STEP 7: Test Docker Locally

```bash
# Build and run development container
npm run docker:dev

# Check logs
npm run docker:logs

# Test the API
curl http://localhost:3000/

# Stop containers
npm run docker:dev:down
```

---

## PHASE 2: CI/CD WITH GITHUB ACTIONS

---

### STEP 8: Create CI Pipeline

üìÅ **File:** `.github/workflows/ci.yml`

```yaml
# ============================================
# CONTINUOUS INTEGRATION PIPELINE
# ============================================

name: CI Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: "20.x"

jobs:
  # ==========================================
  # Job 1: Lint & Type Check
  # ==========================================
  lint:
    name: Lint & Type Check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Type check
        run: npx tsc --noEmit

  # ==========================================
  # Job 2: Run Tests
  # ==========================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: lint

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        run: npm run test:coverage
        env:
          NODE_ENV: test
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
          JWT_SECRET: test-secret

      - name: Upload coverage report
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/lcov.info
          fail_ci_if_error: false

  # ==========================================
  # Job 3: Build Application
  # ==========================================
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build TypeScript
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/
          retention-days: 1

  # ==========================================
  # Job 4: Build Docker Image
  # ==========================================
  docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/task-manager-api:latest
            ${{ secrets.DOCKER_USERNAME }}/task-manager-api:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ==========================================
  # Job 5: Security Scan
  # ==========================================
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: lint

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run npm audit
        run: npm audit --audit-level=moderate
        continue-on-error: true

      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
```

---

### STEP 9: Create CD Pipeline

üìÅ **File:** `.github/workflows/deploy.yml`

```yaml
# ============================================
# CONTINUOUS DEPLOYMENT PIPELINE
# ============================================

name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch: # Allow manual trigger

env:
  NODE_VERSION: "20.x"

jobs:
  # ==========================================
  # Job 1: Deploy to Railway
  # ==========================================
  deploy-railway:
    name: Deploy to Railway
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Railway CLI
        run: npm install -g @railway/cli

      - name: Deploy to Railway
        run: railway up --service task-manager-api
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

  # ==========================================
  # Job 2: Deploy to Render (Alternative)
  # ==========================================
  deploy-render:
    name: Deploy to Render
    runs-on: ubuntu-latest
    if: false # Set to true if using Render instead

    steps:
      - name: Trigger Render Deploy
        run: |
          curl -X POST "${{ secrets.RENDER_DEPLOY_HOOK }}"

  # ==========================================
  # Job 3: Post-Deployment Checks
  # ==========================================
  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: deploy-railway

    steps:
      - name: Wait for deployment
        run: sleep 60

      - name: Health check
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.PRODUCTION_URL }}/)
          if [ "$response" != "200" ]; then
            echo "Health check failed with status: $response"
            exit 1
          fi
          echo "Health check passed!"

      - name: API check
        run: |
          response=$(curl -s ${{ secrets.PRODUCTION_URL }}/api)
          echo "API Response: $response"

  # ==========================================
  # Job 4: Notify on Success/Failure
  # ==========================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [deploy-railway, verify-deployment]
    if: always()

    steps:
      - name: Notify on success
        if: ${{ needs.verify-deployment.result == 'success' }}
        run: |
          echo "‚úÖ Deployment successful!"
          # Add Slack/Discord webhook here

      - name: Notify on failure
        if: ${{ needs.verify-deployment.result == 'failure' }}
        run: |
          echo "‚ùå Deployment failed!"
          # Add Slack/Discord webhook here
```

---

### STEP 10: Set Up GitHub Secrets

Go to your GitHub repo ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions

Add these secrets:

| Secret Name         | Description                             |
| ------------------- | --------------------------------------- |
| `SUPABASE_URL`      | Your Supabase project URL               |
| `SUPABASE_ANON_KEY` | Your Supabase anon key                  |
| `DOCKER_USERNAME`   | Docker Hub username                     |
| `DOCKER_PASSWORD`   | Docker Hub password or access token     |
| `RAILWAY_TOKEN`     | Railway API token                       |
| `PRODUCTION_URL`    | Your deployed API URL                   |
| `CODECOV_TOKEN`     | (Optional) Codecov token for coverage   |
| `SNYK_TOKEN`        | (Optional) Snyk token for security scan |

---

## PHASE 3: DEPLOY TO RAILWAY

---

### STEP 11: Create Railway Account & Project

1. Go to https://railway.app
2. Sign up with GitHub
3. Click **"New Project"**
4. Select **"Deploy from GitHub repo"**
5. Select your task-manager-api repository
6. Railway will auto-detect it's a Node.js project

---

### STEP 12: Configure Railway Environment Variables

In Railway dashboard ‚Üí Your project ‚Üí Variables:

```bash
NODE_ENV=production
PORT=3000
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
JWT_SECRET=your-production-jwt-secret
FRONTEND_URL=https://your-frontend.com
PASSWORD_RESET_URL=https://your-frontend.com/reset-password
```

---

### STEP 13: Create railway.json Configuration

üìÅ **File:** `railway.json`

```json
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS",
    "buildCommand": "npm ci && npm run build"
  },
  "deploy": {
    "startCommand": "npm start",
    "healthcheckPath": "/",
    "healthcheckTimeout": 100,
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}
```

---

### STEP 14: Alternative - Deploy to Render

1. Go to https://render.com
2. Connect your GitHub
3. Create **"New Web Service"**
4. Select your repository
5. Configure:
   - **Build Command:** `npm ci && npm run build`
   - **Start Command:** `npm start`
   - **Environment:** Node
6. Add environment variables
7. Deploy!

üìÅ **File:** `render.yaml` (Optional - Infrastructure as Code)

```yaml
services:
  - type: web
    name: task-manager-api
    env: node
    region: oregon
    plan: free
    buildCommand: npm ci && npm run build
    startCommand: npm start
    healthCheckPath: /
    envVars:
      - key: NODE_ENV
        value: production
      - key: PORT
        value: 3000
      - key: SUPABASE_URL
        sync: false
      - key: SUPABASE_ANON_KEY
        sync: false
      - key: JWT_SECRET
        generateValue: true
```

---

## PHASE 4: MONITORING & HEALTH CHECKS

---

### STEP 15: Create Health Check Endpoint

üìÅ **File:** `src/routes/healthRoutes.ts` (New file)

```typescript
// ============================================
// HEALTH CHECK ROUTES
// ============================================

import { Router, Request, Response } from "express";
import supabase from "../config/supabase";

const router = Router();

/**
 * GET /health
 * Basic health check - returns 200 if server is running
 */
router.get("/", (req: Request, res: Response) => {
  res.status(200).json({
    status: "healthy",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV,
  });
});

/**
 * GET /health/ready
 * Readiness check - verifies all dependencies are available
 */
router.get("/ready", async (req: Request, res: Response) => {
  const checks = {
    server: true,
    database: false,
    timestamp: new Date().toISOString(),
  };

  try {
    // Check database connection
    const { error } = await supabase.from("tasks").select("id").limit(1);
    checks.database = !error;
  } catch {
    checks.database = false;
  }

  const isReady = checks.server && checks.database;

  res.status(isReady ? 200 : 503).json({
    status: isReady ? "ready" : "not ready",
    checks,
  });
});

/**
 * GET /health/live
 * Liveness check - verifies server is responding
 */
router.get("/live", (req: Request, res: Response) => {
  res.status(200).json({
    status: "alive",
    timestamp: new Date().toISOString(),
  });
});

/**
 * GET /health/metrics
 * Basic metrics endpoint
 */
router.get("/metrics", (req: Request, res: Response) => {
  const memoryUsage = process.memoryUsage();

  res.status(200).json({
    uptime: process.uptime(),
    memory: {
      heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024) + " MB",
      heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024) + " MB",
      rss: Math.round(memoryUsage.rss / 1024 / 1024) + " MB",
    },
    cpu: process.cpuUsage(),
    timestamp: new Date().toISOString(),
  });
});

export default router;
```

---

### STEP 16: Update app.ts with Health Routes

```typescript
// Add import
import healthRoutes from "./routes/healthRoutes";

// Add route (BEFORE other routes, no auth required)
app.use("/health", healthRoutes);
```

---

### STEP 17: Add Error Tracking (Optional - Sentry)

```bash
npm install @sentry/node
```

üìÅ **File:** `src/config/sentry.ts` (New file)

```typescript
// ============================================
// SENTRY ERROR TRACKING
// ============================================

import * as Sentry from "@sentry/node";
import { Application } from "express";

export const initSentry = (app: Application): void => {
  if (!process.env.SENTRY_DSN) {
    console.log("‚ö†Ô∏è Sentry DSN not configured, error tracking disabled");
    return;
  }

  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    environment: process.env.NODE_ENV,

    // Performance monitoring
    tracesSampleRate: process.env.NODE_ENV === "production" ? 0.1 : 1.0,

    // Release tracking
    release: process.env.npm_package_version,

    // Integrations
    integrations: [
      // HTTP request tracking
      new Sentry.Integrations.Http({ tracing: true }),
      // Express integration
      new Sentry.Integrations.Express({ app }),
    ],
  });

  // Request handler - must be first middleware
  app.use(Sentry.Handlers.requestHandler());

  // Tracing handler
  app.use(Sentry.Handlers.tracingHandler());

  console.log("‚úÖ Sentry error tracking initialized");
};

export const initSentryErrorHandler = (app: Application): void => {
  if (!process.env.SENTRY_DSN) return;

  // Error handler - must be before any other error middleware
  app.use(Sentry.Handlers.errorHandler());
};

export { Sentry };
```

---

### STEP 18: Create Production Environment File

üìÅ **File:** `.env.production.example`

```env
# ============================================
# PRODUCTION ENVIRONMENT VARIABLES
# ============================================

# Server
NODE_ENV=production
PORT=3000

# Supabase (use production project)
SUPABASE_URL=https://your-production-project.supabase.co
SUPABASE_ANON_KEY=your-production-anon-key

# JWT (use strong secret in production)
JWT_SECRET=generate-a-strong-256-bit-secret-here

# Frontend URLs
FRONTEND_URL=https://your-production-frontend.com
PASSWORD_RESET_URL=https://your-production-frontend.com/reset-password

# Monitoring (Optional)
SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx

# Logging
LOG_LEVEL=info
```

---

## PHASE 5: PRODUCTION CHECKLIST

---

### Pre-Deployment Checklist

| Item                      | Status | Notes                      |
| ------------------------- | ------ | -------------------------- |
| All tests passing         | ‚òê      | `npm test`                 |
| No linting errors         | ‚òê      | `npm run lint`             |
| TypeScript compiles       | ‚òê      | `npm run build`            |
| Environment variables set | ‚òê      | Check all required vars    |
| Database migrations run   | ‚òê      | Check Supabase             |
| RLS policies enabled      | ‚òê      | Check Supabase             |
| Docker image builds       | ‚òê      | `npm run docker:build`     |
| Health endpoints work     | ‚òê      | Test `/health` routes      |
| Rate limiting configured  | ‚òê      | Test rate limits           |
| Security headers enabled  | ‚òê      | Check Helmet headers       |
| CORS configured correctly | ‚òê      | Test from frontend         |
| Secrets not in code       | ‚òê      | Check for hardcoded values |
| Error tracking configured | ‚òê      | Optional: Sentry           |

---

### Post-Deployment Checklist

| Item                        | Status | Notes                   |
| --------------------------- | ------ | ----------------------- |
| Health check returns 200    | ‚òê      | `curl $PROD_URL/health` |
| API endpoints accessible    | ‚òê      | Test all routes         |
| Authentication works        | ‚òê      | Test login/signup       |
| Database connection working | ‚òê      | Test CRUD operations    |
| SSL certificate valid       | ‚òê      | Check HTTPS             |
| Custom domain configured    | ‚òê      | If applicable           |
| Monitoring alerts set up    | ‚òê      | Configure notifications |
| Backup strategy in place    | ‚òê      | Supabase handles this   |

---

# üìä Deployment Commands Reference

```bash
# ==========================================
# LOCAL DEVELOPMENT
# ==========================================

# Start development server
npm run dev

# Run with Docker
npm run docker:dev

# Run tests
npm test

# Build for production
npm run build

# ==========================================
# DOCKER COMMANDS
# ==========================================

# Build Docker image
docker build -t task-manager-api .

# Run Docker container
docker run -p 3000:3000 --env-file .env task-manager-api

# Run with docker-compose (dev)
docker-compose up --build

# Run with docker-compose (prod)
docker-compose -f docker-compose.prod.yml up -d

# View logs
docker-compose logs -f

# Stop containers
docker-compose down

# Clean up Docker
docker system prune -af

# ==========================================
# RAILWAY COMMANDS
# ==========================================

# Install Railway CLI
npm install -g @railway/cli

# Login to Railway
railway login

# Link to project
railway link

# Deploy
railway up

# View logs
railway logs

# Open project in browser
railway open

# ==========================================
# USEFUL CURL COMMANDS
# ==========================================

# Health check
curl https://your-api.com/health

# Readiness check
curl https://your-api.com/health/ready

# API documentation
curl https://your-api.com/api

# Test with auth
curl -H "Authorization: Bearer <token>" https://your-api.com/api/tasks
```

---

# üéâ CONGRATULATIONS!

Your API is now **production-ready** with:

- ‚úÖ **Docker Containerization** - Consistent deployments
- ‚úÖ **CI/CD Pipeline** - Automated testing & deployment
- ‚úÖ **Cloud Deployment** - Railway/Render hosting
- ‚úÖ **Health Monitoring** - Proactive issue detection
- ‚úÖ **Security** - Helmet, rate limiting, environment isolation

---

# üöÄ What's Next?

You've completed the full journey from a basic Express API to a production-ready application! Here are some ideas for further learning:

1. **Add a Frontend** - Build a React/Next.js app that consumes this API
2. **Add GraphQL** - Create a GraphQL layer alongside REST
3. **Implement Caching** - Add Redis for improved performance
4. **Add Search** - Implement full-text search with PostgreSQL or Elasticsearch
5. **Build Mobile Apps** - Create iOS/Android apps using this API
6. **Microservices** - Split into separate services as it grows

**Happy coding!** üéØ
